
module Verification.Core.Theory.Std.Specific.ProductTheory.Instance.ToCheckTree2 where

open import Verification.Conventions hiding (_‚äî_ ; lookup)
open import Verification.Core.Set.Discrete
open import Verification.Core.Set.Contradiction
open import Verification.Core.Set.Setoid.Definition
open import Verification.Core.Set.Function.Surjective
open import Verification.Core.Data.Nat.Free
open import Verification.Core.Data.Sum.Definition
open import Verification.Core.Data.Product.Definition
open import Verification.Core.Data.Sum.Instance.Functor
open import Verification.Core.Category.Std.Monad.Definition
open import Verification.Core.Category.Std.Monad.KleisliCategory.Instance.Monoidal
open import Verification.Core.Category.Std.Monad.TypeMonadNotation
open import Verification.Core.Data.Sum.Instance.Monad
open import Verification.Core.Data.Universe.Everything
open import Verification.Core.Theory.Std.Specific.ProductTheory.Definition
open import Verification.Core.Theory.Std.Presentation.Token.Definition
open import Verification.Core.Category.Std.Category.Definition
open import Verification.Core.Category.Std.Functor.Definition
open import Verification.Core.Category.Std.Category.Subcategory.Definition
open import Verification.Core.Category.Std.Category.Subcategory.Full
open import Verification.Core.Data.Indexed.Definition
open import Verification.Core.Data.Indexed.Instance.Monoid
open import Verification.Core.Data.FiniteIndexed.Definition
open import Verification.Core.Algebra.Monoid.Definition
open import Verification.Core.Algebra.Monoid.Free
open import Verification.Core.Data.List.Variant.Binary.Element
open import Verification.Core.Data.Substitution.Variant.Base.Definition
open import Verification.Core.Data.Substitution.Property.Base
open import Verification.Core.Theory.Std.Presentation.NGraph.Definition
open import Verification.Core.Category.Std.Limit.Specific.Coproduct.Definition
open import Verification.Core.Category.Std.Morphism.Iso

open import Verification.Core.Category.Std.RelativeMonad.Definition
open import Verification.Core.Category.Std.RelativeMonad.KleisliCategory.Definition


-- open import Verification.Core.Theory.Std.Specific.ProductTheory.Instance.FromString2
open import Verification.Core.Theory.Std.Presentation.CheckTree.Definition2
open import Verification.Core.Theory.Std.Specific.ProductTheory.Instance.FromANVecTree
open import Verification.Core.Theory.Std.Specific.ProductTheory.Instance.hasBoundaries


module _ {A : ùí∞ ùëñ} {B : ùí∞ ùëó} where
  comm-lookup-map : ‚àÄ{f : A -> B} -> ‚àÄ{i : Fin-R n} -> ‚àÄ{as : Vec A n} -> lookup i (map-Vec f as) ‚â° f (lookup i as)
  comm-lookup-map = {!!}


    -- node : (a : A) -> (‰∫∫Vec VecTree (l a)) -> VecTree
    -- var  : B -> VecTree

-- module _ {A : ùí∞ ùëñ} {l : A -> ‰∫∫‚Ñï' ùëñ} where
--   data TreeStep1 : (t s : VecTree1 A l) -> ùí∞ ùëñ where

--     incl : ‚àÄ{a : A} -> (ts : ([ l a ]·∂† -> (VecTree1 A l))) -> (i : [ l a ]·∂†)
--            -> TreeStep1 (node1 a ts) (ts i)

--   data TreePath1 : (t s : VecTree1 A l) -> ùí∞ (ùëñ) where
--     [] : ‚àÄ{t : VecTree1 A l} -> TreePath1 t t
--     step : ‚àÄ{r s t : (VecTree1 A l)} -> TreePath1 r s -> TreeStep1 s t -> TreePath1 r t


--   Vertex1 : (r : VecTree1 A l) -> ùí∞ _
--   Vertex1 r = ‚àë TreePath1 r

-- module _ {A : ùí∞ ùëñ} {l : A -> ‚Ñï} {‚Ñ¨ : ùí∞ ùëñ} {{_ : isCategory {ùëó} ‚Ñ¨}} {{_ : isSet-Str ‚Ñ¨}} {F : Functor ‚Ä≤ ‚Ñ¨ ‚Ä≤ (ùêîùêßùê¢ùêØ ùëô)} where
--   module _ (b : ‚Ñ¨) where
--     data isANVecTree : (‚ü® F ‚ü© b) -> ùí∞ (ùëñ ÔΩ§ ùëó ÔΩ§ ùëô) where
--       node1 : (a : A) -> (Vec VecTree1 (l a)) -> VecTree1


-- module _ {A : ùí∞ ùëñ} {B : ùí∞ ùëó} where
--   map-Vec : ‚àÄ{n} -> (f : A -> B) -> Vec A n -> Vec B n
--   map-Vec = ?

infixl 30 _‚àô-‚â°_
_‚àô-‚â°_ = trans-Path


module _ {A : ùí∞ ùëñ} {l : A -> ‚Ñï} {‚Ñ¨ : ùí∞ ùëñ} {{_ : isCategory {ùëó} ‚Ñ¨}} {{_ : isSet-Str ‚Ñ¨}} {F : Functor ‚Ä≤ ‚Ñ¨ ‚Ä≤ (ùêîùêßùê¢ùêØ ùëô)} {{_ : isCheckingBoundary ‚Ä≤ ‚Ñ¨ ‚Ä≤ F}} where

  module _ (initb : A -> ‚Ñ¨)
           (initv : ‚àÄ(a : A) -> ‚ü® F ‚ü© (initb a))
           (initvs : ‚àÄ(a : A) -> Vec (‚ü® F ‚ü© (initb a)) (l a))
           (WT : ‚àÄ{b} -> (a : A) -> ‚ü® F ‚ü© b -> Vec (‚ü® F ‚ü© b) (l a) -> ùí∞ ùëò)
           where

    -- ADANVecTree1 : 
    ADANVecTree1 = ADANVecTree A l ‚Ñ¨ F WT

    mutual
      makeInitialTrees : ‚àÄ{n} -> Vec (VecTree1 A l) n -> Vec (‚àë ADANVecTree A l ‚Ñ¨ F WT) n
      makeInitialTrees ‚¶ã‚¶å = ‚¶ã‚¶å
      makeInitialTrees (x ‚à∑ ts) = (makeInitialTree x) ‚à∑ (makeInitialTrees ts)

      makeInitialTree : VecTree1 A l -> ‚àë ADANVecTree A l ‚Ñ¨ F WT
      makeInitialTree (node1 a x) = _ , (node1 a (initb a) (initv a) (initvs a) {!!} (makeInitialTrees x))

    mutual
      ibounds : ‚ãÜList ‚Ñ¨ -> Vec (‚àë ADANVecTree1) n -> ‚ãÜList ‚Ñ¨
      ibounds ac ‚¶ã‚¶å = ac
      ibounds ac (x ‚à∑ v) = ibounds (ac ‚ãÜ ibound x) v

      ibound : ‚àë ADANVecTree1 -> ‚ãÜList ‚Ñ¨
      ibound (_ , node1 a b _ _ _ x) = ibounds (incl b) x

    private
      lem-1 : ‚àÄ{a} -> {ac : ‚ãÜList ‚Ñ¨} -> (ts : Vec (‚àë ADANVecTree1) n) -> ac ‚àç a -> ibounds ac ts ‚àç a
      lem-1 ‚¶ã‚¶å p = p
      lem-1 (x ‚à∑ ts) p = lem-1 ts (left-‚àç p)

      lem-1' : (t : ‚àë ADANVecTree1) -> ibound t ‚àç (t .fst .fst)
      lem-1' (_ , node1 a _ _ _ _ x) = lem-1 x incl

      lem-2 : ‚àÄ{a} -> {ac : ‚ãÜList ‚Ñ¨} -> (ts : Vec (‚àë ADANVecTree1) n) -> (i : Fin-R n) -> ibound (lookup i ts) ‚àç a -> ibounds ac ts ‚àç a
      lem-2 (x ‚à∑ ts) zero p = lem-1 ts (right-‚àç p)
      lem-2 (x ‚à∑ ts) (suc i) p = lem-2 ts i p


    mutual
      appendStrategy : ‚àÄ{as a} -> (s : Strategy as) -> (as ‚àç a) -> (vs : Vec (‚ü® F ‚ü© a) n) -> (v : Vec (‚àë ADANVecTree1) n) -> Strategy (ibounds as v)
      appendStrategy s as‚àça ‚¶ã‚¶å ‚¶ã‚¶å = s
      appendStrategy s as‚àça (v ‚à∑ vs) (t@((tb , tv) , ttree) ‚à∑ ts) =
        let tstrat = makeStrategy t
        in appendStrategy (resolve s tstrat (rtarget _ as‚àça v , rtarget tb (lem-1' t) tv)) (left-‚àç as‚àça) vs ts

      makeStrategy : (v : ‚àë ADANVecTree1) -> Strategy (ibound v)
      makeStrategy (_ , node1 a b v vs _ x) = appendStrategy (begin b) incl vs x -- , rt1


{-
    isValidStrategy1 : ‚àÄ{as b} -> (t : ADANVecTree A l ‚Ñ¨ F WT b) -> (s : Strategy as) -> ùí∞ _
    isValidStrategy1 {as} {b} t _ = ‚àÄ{b1} -> (v1 : ‚ü® F ‚ü© b1) -> (ADANVertex A l ‚Ñ¨ F WT) v1 (_ , t) -> as ‚àç b1

    isValidStrategy2 : ‚àÄ{as b} -> (t : ADANVecTree A l ‚Ñ¨ F WT b) -> (s : Strategy as) -> ùí∞ _
    isValidStrategy2 t s = ‚àÄ{b1 b2} -> (v1 : ‚ü® F ‚ü© b1) (v2 : ‚ü® F ‚ü© b2) (vout : ‚ü® F ‚ü© b1)-> (ADANEdge A l ‚Ñ¨ F WT) v1 v2 vout (_ , t) -> s ‚àç-St‚ÇÇ (rtarget b1 vout , rtarget b2 v2)

    isValidStrategy3‚ÇÄ : ‚àÄ{as b} -> (t : ADANVecTree A l ‚Ñ¨ F WT b) -> (s : Strategy as)
                       -> (valid1 : isValidStrategy1 t s) -> (valid2 : isValidStrategy2 t s) -> ùí∞ _
    isValidStrategy3‚ÇÄ t s valid1 valid2 = ‚àÄ{b1 b2} -> (v1 : ‚ü® F ‚ü© b1) (v2 : ‚ü® F ‚ü© b2) (vout : ‚ü® F ‚ü© b1)-> (e : (ADANEdge A l ‚Ñ¨ F WT) v1 v2 vout (_ , t))
                                 -> getElemSt‚ÇÄ (valid2 v1 v2 vout e) ‚â° valid1 v1 (e .fst , e .snd .snd .fst)

    isValidStrategy3‚ÇÅ : ‚àÄ{as b} -> (t : ADANVecTree A l ‚Ñ¨ F WT b) -> (s : Strategy as)
                       -> (valid1 : isValidStrategy1 t s) -> (valid2 : isValidStrategy2 t s) -> ùí∞ _
    isValidStrategy3‚ÇÅ t s valid1 valid2 = ‚àÄ{b1 b2} -> (v1 : ‚ü® F ‚ü© b1) (v2 : ‚ü® F ‚ü© b2) (vout : ‚ü® F ‚ü© b1)-> (e : (ADANEdge A l ‚Ñ¨ F WT) v1 v2 vout (_ , t))
                                 -> getElemSt‚ÇÅ (valid2 v1 v2 vout e) ‚â° valid1 v2 ((e .snd .fst) , (step (e .snd .snd .fst) (e .snd .snd .snd))) -- (e .fst , e .snd .snd .fst)
                                 -}

    -- we show that `makeStrategy` creates a valid strategy

    module myproofs1 where


      Pstep : ‚àÄ{b} -> {t s : ‚àë ADANVecTree1}
                    -> ‚àÄ{vout}
                    -> ADANTreeStep A l ‚Ñ¨ F WT (t) (s) vout
                    -> ibound s ‚àç b -> ibound t ‚àç b
      Pstep (incl a b v vs wt ts i) bp = lem-2 ts i bp

      Ppath : ‚àÄ{b} -> {t s : ‚àë ADANVecTree1}
                    -> ADANTreePath A l ‚Ñ¨ F WT (t) (s)
                    -> ibound s ‚àç b -> ibound t ‚àç b
      Ppath [] bp = bp
      Ppath (step p x) bp = Ppath p (Pstep x bp)

      P : ‚àÄ{t s : ‚àë ADANVecTree1} -> ADANTreePath A l ‚Ñ¨ F WT t s -> ibound t ‚àç s .fst .fst
      P {t = t} {s} p = Ppath p (lem-1' s)

      -- about edges
      map-append : ‚àÄ{as a} -> {s : Strategy as} -> {p : as ‚àç a} -> {vs : Vec (‚ü® F ‚ü© a) n} -> {ts : Vec (‚àë ADANVecTree1) n}
                   -> (rp : ResolutionPair‚ÇÇ)
                   -> s ‚àç-St‚ÇÇ rp
                   -> appendStrategy s p vs ts ‚àç-St‚ÇÇ rp
      map-append {vs = ‚¶ã‚¶å} {‚¶ã‚¶å} rp p = p
      map-append {vs = x ‚à∑ vs} {x‚ÇÅ ‚à∑ ts} rp p = map-append {vs = vs} {ts} rp (left-‚àç p)



      P1s : ‚àÄ{as a} -> {s : Strategy as} -> {p : as ‚àç a} -> (vs : Vec (‚ü® F ‚ü© a) n) -> (ts : Vec (‚àë ADANVecTree1) n)
            -> (i : Fin-R n)
            -> appendStrategy s p vs ts ‚àç-St‚ÇÇ
                (rtarget a (lookup i vs) ,
                rtarget (lookup i ts .fst .fst) (lookup i ts .fst .snd))
      P1s {as = as} {a} {s = s} {p} (x ‚à∑ vs) (t@((tb , tv) , ttree) ‚à∑ ts) zero = map-append {vs = vs} {ts = ts} _ (incl _ _ p (lem-1' t) x tv)
      P1s {s = s} (x ‚à∑ vs) (t@((tb , tv) , node1 a .tb .tv vs‚ÇÅ x‚ÇÅ x‚ÇÇ) ‚à∑ ts) (suc i) = P1s vs ts i




      lem-4 : ‚àÄ{as a} -> (s : Strategy as) -> (p : as ‚àç a) -> (vs : Vec (‚ü® F ‚ü© a) n) -> (ts : Vec (‚àë ADANVecTree1) n)
                   -> (rp : ResolutionPair‚ÇÇ)
                   -> (i : Fin-R n)
                   -> makeStrategy (lookup i ts) ‚àç-St‚ÇÇ rp
                   -> appendStrategy s p vs ts ‚àç-St‚ÇÇ rp
      lem-4 s p (x ‚à∑ vs) (t ‚à∑ ts) rp zero sp = map-append {vs = vs} {ts = ts} _ (right-‚àç sp)
      lem-4 s p (x ‚à∑ vs) (x‚ÇÅ ‚à∑ ts) rp (suc i) sp = lem-4 _ _ vs ts rp i sp


      P1 : {t s : ‚àë ADANVecTree1} -> ‚àÄ{vout} -> ADANTreeStep A l ‚Ñ¨ F WT t s vout -> makeStrategy t ‚àç-St‚ÇÇ ((rtarget _ vout) , (rtarget (s .fst .fst) (s .fst .snd)))
      P1 (incl a b v vs wt ts i) = P1s vs ts i

      P1step : {t s : ‚àë ADANVecTree1} -> ‚àÄ{vout} -> ADANTreeStep A l ‚Ñ¨ F WT t s vout
               -> ‚àÄ{rp : ResolutionPair‚ÇÇ} -> makeStrategy s ‚àç-St‚ÇÇ rp -> makeStrategy t ‚àç-St‚ÇÇ rp
      P1step (incl a b v vs wt ts i) {rp} sp = lem-4 (begin b) incl vs ts rp i sp

{-
      P1path : {t s : ‚àë ADANVecTree1} -> ADANTreePath A l ‚Ñ¨ F WT t s
               -> ‚àÄ{rp : ResolutionPair‚ÇÇ} -> makeStrategy s ‚àç-St‚ÇÇ rp -> makeStrategy t ‚àç-St‚ÇÇ rp
      P1path [] P = P
      P1path (step pat x) P = P1path pat (P1step x P)

      -- lem-1‚ÇÄ : ‚àÄ{a} -> {ac : ‚ãÜList ‚Ñ¨} -> {ts : Vec (‚àë ADANVecTree1) n} -> {ac ‚àç a} -> ibounds ac ts ‚àç a


      lem-1‚ÇÄ : ‚àÄ{as a} -> (s : Strategy as)
                    -> (p : as ‚àç a) -> (vs : Vec (‚ü® F ‚ü© a) n) -> (ts : Vec (‚àë ADANVecTree1) n)
                   -> (rp : ResolutionPair‚ÇÇ)
                   -> {sep : s ‚àç-St‚ÇÇ rp}
                   -> {bop : as ‚àç rp .fst .fst}
                   -> getElemSt‚ÇÄ sep ‚â° bop
                   -> getElemSt‚ÇÄ (map-append {s = s} {p = p} {vs = vs} {ts = ts} rp (sep)) ‚â° lem-1 ts (bop)
      lem-1‚ÇÄ s p ‚¶ã‚¶å ‚¶ã‚¶å rp sepbop = sepbop
      lem-1‚ÇÄ s p (x ‚à∑ vs) (x‚ÇÅ ‚à∑ ts) rp sepbop = lem-1‚ÇÄ _ _ vs ts rp (cong left-‚àç sepbop) -- sepbop

-}

      lem-1‚ÇÅ : ‚àÄ{as a} -> (s : Strategy as)
                    -> (p : as ‚àç a) -> (vs : Vec (‚ü® F ‚ü© a) n) -> (ts : Vec (‚àë ADANVecTree1) n)
                   -> (rp : ResolutionPair‚ÇÇ)
                   -> {sep : s ‚àç-St‚ÇÇ rp}
                   -> {bop : as ‚àç rp .snd .fst}
                   -> getElemSt‚ÇÅ sep ‚â° bop
                   -> getElemSt‚ÇÅ (map-append {s = s} {p = p} {vs = vs} {ts = ts} rp (sep)) ‚â° lem-1 ts (bop)
      lem-1‚ÇÅ s p ‚¶ã‚¶å ‚¶ã‚¶å rp sepbop = sepbop
      lem-1‚ÇÅ s p (x ‚à∑ vs) (x‚ÇÅ ‚à∑ ts) rp sepbop = lem-1‚ÇÅ _ _ vs ts rp (cong left-‚àç sepbop) -- sepbop

      -- lem-1u : ‚àÄ{as a} -> (s : Strategy as)
      --               -> (p : as ‚àç a) -> (vs : Vec (‚ü® F ‚ü© a) n) -> (ts : Vec (‚àë ADANVecTree1) n)
      --              -> (rp : ResolutionPair‚ÇÇ)
      --              -> {sep : s ‚àç-St‚ÇÇ rp}
      --              -> getElemSt‚ÇÄ (map-append {s = s} {p = p} {vs = vs} {ts = ts} rp (sep)) ‚â° lem-1 ts (getElemSt‚ÇÄ sep)
      -- lem-1u s p ‚¶ã‚¶å ‚¶ã‚¶å rp sepbop = sepbop
      -- lem-1u s p (x ‚à∑ vs) (x‚ÇÅ ‚à∑ ts) rp sepbop = lem-1‚ÇÄ _ _ vs ts rp (cong left-‚àç sepbop) -- sepbop

{-
      lem-42‚ÇÄ : ‚àÄ{as a} -> (s : Strategy as) -> (p : as ‚àç a) -> (vs : Vec (‚ü® F ‚ü© a) n) -> (ts : Vec (‚àë ADANVecTree1) n)
                   -> (rp : ResolutionPair‚ÇÇ)
                   -> (i : Fin-R n)
                   -> {sep : makeStrategy (lookup i ts) ‚àç-St‚ÇÇ rp}
                   -> {bop : ibound (lookup i ts) ‚àç rp .fst .fst}
                   -> getElemSt‚ÇÄ sep ‚â° bop
                   -> getElemSt‚ÇÄ (lem-4 s p vs ts rp i sep) ‚â° lem-2 ts i bop
      lem-42‚ÇÄ s p (x ‚à∑ vs) (x‚ÇÅ ‚à∑ ts) rp zero sepbop = lem-1‚ÇÄ _ _ vs ts rp (cong right-‚àç sepbop) -- sepbop
      lem-42‚ÇÄ s p (x ‚à∑ vs) (x‚ÇÅ ‚à∑ ts) rp (suc i) sepbop = lem-42‚ÇÄ _ _ vs ts rp i sepbop

-}
      lem-42‚ÇÅ : ‚àÄ{as a} -> (s : Strategy as) -> (p : as ‚àç a) -> (vs : Vec (‚ü® F ‚ü© a) n) -> (ts : Vec (‚àë ADANVecTree1) n)
                   -> (rp : ResolutionPair‚ÇÇ)
                   -> (i : Fin-R n)
                   -> {sep : makeStrategy (lookup i ts) ‚àç-St‚ÇÇ rp}
                   -> {bop : ibound (lookup i ts) ‚àç rp .snd .fst}
                   -> getElemSt‚ÇÅ sep ‚â° bop
                   -> getElemSt‚ÇÅ (lem-4 s p vs ts rp i sep) ‚â° lem-2 ts i bop
      lem-42‚ÇÅ s p (x ‚à∑ vs) (x‚ÇÅ ‚à∑ ts) rp zero sepbop = lem-1‚ÇÅ _ _ vs ts rp (cong right-‚àç sepbop) -- sepbop
      lem-42‚ÇÅ s p (x ‚à∑ vs) (x‚ÇÅ ‚à∑ ts) rp (suc i) sepbop = lem-42‚ÇÅ _ _ vs ts rp i sepbop

{-
      lem-step : {t s : ‚àë ADANVecTree1} -> ‚àÄ{vout} -> (pat : ADANTreeStep A l ‚Ñ¨ F WT t s vout)
               -> ‚àÄ{rp : ResolutionPair‚ÇÇ} -> {sep : makeStrategy s ‚àç-St‚ÇÇ rp}
               -> {bop : ibound s ‚àç rp .fst .fst}
               -> getElemSt‚ÇÄ sep ‚â° bop
               -> getElemSt‚ÇÄ (P1step pat sep) ‚â°  (Pstep pat bop)
      lem-step (incl a b v vs wt ts i) {rp} p = lem-42‚ÇÄ (begin b) incl vs ts rp i p


      lem-path : {t s : ‚àë ADANVecTree1} -> (pat : ADANTreePath A l ‚Ñ¨ F WT t s)
               -> ‚àÄ{rp : ResolutionPair‚ÇÇ} -> {sep : makeStrategy s ‚àç-St‚ÇÇ rp}
               -> {bop : ibound s ‚àç rp .fst .fst}
               -> getElemSt‚ÇÄ sep ‚â° bop
               -> getElemSt‚ÇÄ (P1path pat sep) ‚â°  (Ppath pat bop)
      lem-path [] p = p
      lem-path (step pat x) p = lem-path pat (lem-step x p)


      lem-step‚ÇÅ : {t s : ‚àë ADANVecTree1} -> ‚àÄ{vout} -> (pat : ADANTreeStep A l ‚Ñ¨ F WT t s vout)
               -> ‚àÄ{rp : ResolutionPair‚ÇÇ} -> {sep : makeStrategy s ‚àç-St‚ÇÇ rp}
               -> {bop : ibound s ‚àç rp .snd .fst}
               -> getElemSt‚ÇÅ sep ‚â° bop
               -> getElemSt‚ÇÅ (P1step pat sep) ‚â°  (Pstep pat bop)
      lem-step‚ÇÅ (incl a b v vs wt ts i) sepbop = lem-42‚ÇÅ (begin b) incl vs ts _ i sepbop
-}
{-
      lem-path‚ÇÅ : {t s : ‚àë ADANVecTree1} -> (pat : ADANTreePath A l ‚Ñ¨ F WT t s)
               -> ‚àÄ{rp : ResolutionPair‚ÇÇ} -> {sep : makeStrategy s ‚àç-St‚ÇÇ rp}
               -> {bop : ibound s ‚àç rp .snd .fst}
               -> getElemSt‚ÇÅ sep ‚â° bop
               -> getElemSt‚ÇÅ (P1path pat sep) ‚â°  (Ppath pat bop)
      lem-path‚ÇÅ [] p = p
      lem-path‚ÇÅ (step pat x) p = lem-path‚ÇÅ pat (lem-step‚ÇÅ x p)


      -- same-path : {t s : ‚àë ADANVecTree1} -> (p : ADANTreePath A l ‚Ñ¨ F WT t s) -> ‚àÄ{rp : ResolutionPair‚ÇÇ}
      --             -> (sp : makeStrategy s ‚àç-St‚ÇÇ rp) -> getElemSt‚ÇÄ (P1path p sp) ‚â° P 
      -- same-path p 

      -- same-1 : {t2 t3 : ‚àë ADANVecTree1} -> ‚àÄ{vout} -> (p : ADANTreeStep A l ‚Ñ¨ F WT t2 t3 vout) -> ‚àÄ{rp : ResolutionPair‚ÇÇ}
      --             -> (getElemSt‚ÇÄ (P1 p) ‚â° lem-1' t2) √ó (getElemSt‚ÇÅ (P1 p) ‚â° lem-1' ({!!} , {!t3 .snd!}))
      -- same-1 (incl a b v vs wt ts i) = {!!}

    module _ (t : ‚àë ADANVecTree1) where
      valid1:makeStrategy : isValidStrategy1 (t .snd) (makeStrategy t)
      valid1:makeStrategy v1 (s , vert) = myproofs1.P vert

      valid2:makeStrategy : isValidStrategy2 (t .snd) (makeStrategy t)
      valid2:makeStrategy v1 v2 vout (t2 , t3 , pat , ed) = myproofs1.P1path pat (myproofs1.P1 ed)

      isValidStrategy3‚ÇÄ:makeStrategy : ‚àÄ{b1 b2} -> (v1 : ‚ü® F ‚ü© b1) (v2 : ‚ü® F ‚ü© b2) (vout : ‚ü® F ‚ü© b1)-> (e : (ADANEdge A l ‚Ñ¨ F WT) v1 v2 vout t)
                                  -> getElemSt‚ÇÄ (valid2:makeStrategy v1 v2 vout e) ‚â° valid1:makeStrategy v1 (e .fst , e .snd .snd .fst)
      isValidStrategy3‚ÇÄ:makeStrategy v1 v2 vout (t1 , t2 , p , ed) = myproofs1.lem-path p {!!}


      isValidStrategy3‚ÇÅ:makeStrategy : ‚àÄ{b1 b2} -> (v1 : ‚ü® F ‚ü© b1) (v2 : ‚ü® F ‚ü© b2) (vout : ‚ü® F ‚ü© b1)-> (e : (ADANEdge A l ‚Ñ¨ F WT) v1 v2 vout t)
                                     -> getElemSt‚ÇÅ (valid2:makeStrategy v1 v2 vout e) ‚â° valid1:makeStrategy v2 ((e .snd .fst) , (step (e .snd .snd .fst) (e .snd .snd .snd)))
      isValidStrategy3‚ÇÅ:makeStrategy v1 v2 vout (t1 , t2 , p , ed)= myproofs1.lem-path‚ÇÅ p {!!}

-}

{-
{-

{-
    module _ {as tb} (t : ADANVecTree A l ‚Ñ¨ F WT tb) (s : Strategy as)
             (valids : isValidStrategy1 t s) (valids2 : isValidStrategy2 t s)
             (valids30 : isValidStrategy3‚ÇÄ t s valids valids2)
             (valids31 : isValidStrategy3‚ÇÅ t s valids valids2)
             {bx} (ex : Execution s bx) (exCorrect : isCorrect ex) where


      mutual
        makeFinalTrees : ‚àÄ{n} -> (ts : Vec (‚àë ADANVecTree A l ‚Ñ¨ F WT) n) -> (vs : Vec (‚ü® F ‚ü© bx) n)
                              -> (p : ‚àÄ(i : Fin-R n) -> ADANTreePath A l ‚Ñ¨ F WT (_ , t) (lookup i ts))

                              -> (‚àÄ(i : Fin-R n) -> map (execHom ex
                                                                 (valids (lookup i ts .fst .snd)
                                                                         (lookup i ts .snd , p i)))
                                                        (lookup i ts .fst .snd)
                                                    ‚â°
                                                    lookup i vs
                                 )
                              -> DVec (ANVecTree A l ‚Ñ¨ F WT bx) vs
        makeFinalTrees ‚¶ã‚¶å ‚¶ã‚¶å ps pP = []
        makeFinalTrees ((_ , t) ‚à∑ ts) (v ‚à∑ vs) ps pP = t1 ‚à∑ (makeFinalTrees ts vs (Œª i -> ps (suc i)) (Œª i -> pP (suc i)))
          where
            t0 = makeFinalTree _ t (ps zero)

            t1 : ANVecTree A l ‚Ñ¨ F WT bx v
            t1 = transport (Œª i -> ANVecTree A l ‚Ñ¨ F WT bx (pP zero i)) t0


        makeFinalTree : ‚àÄ{b0} -> (vb0 : ‚ü® F ‚ü© b0) (s : ADANVecTree A l ‚Ñ¨ F WT (b0 , vb0)) -> (p : ADANTreePath A l ‚Ñ¨ F WT (_ , t) (_ , s)) -> ANVecTree A l ‚Ñ¨ F WT bx (map (execHom ex (valids vb0 (s , p))) vb0)
        makeFinalTree {b0} vb0 curtree@(node1 a .b0 .vb0 vs wt ts) p = (node1 a (map f0 vb0) (map-Vec (map f0) vs) {!!} ts')
          where
            sb‚àçb : as ‚àç b0
            sb‚àçb = (valids vb0 (((node1 a b0 vb0 vs wt ts)) , p))

            f0 : b0 ‚ü∂ bx
            f0 = execHom ex sb‚àçb

            getEdge : ‚àÄ(i : Fin-R (l a)) -> ADANEdge A l ‚Ñ¨ F WT vb0 (lookup i ts .fst .snd) (lookup i vs) (_ , t)
            getEdge i = ((node1 a b0 vb0 vs wt ts)) , (lookup i ts .snd , p , (incl a b0 vb0 vs wt ts i))

            rtarget‚àç : ‚àÄ(i : Fin-R (l a)) -> s ‚àç-St‚ÇÇ (rtarget _ (lookup i vs) , rtarget _ (lookup i ts .fst .snd))
            rtarget‚àç i = valids2 _ _ _ (getEdge i)

            lem-02 : ‚àÄ(i : Fin-R (l a))
                    -> map (execHom ex (getElemSt‚ÇÄ (rtarget‚àç i))) (lookup i vs) ‚â° map (execHom ex (getElemSt‚ÇÅ (rtarget‚àç i))) (lookup i ts .fst .snd)
            lem-02 i = exCorrect _ (rtarget‚àç i)

            lem-03 :  ‚àÄ(i : Fin-R (l a))
                    -> map (execHom ex (valids vb0 (curtree , p))) (lookup i vs) ‚â° map (execHom ex (getElemSt‚ÇÄ (rtarget‚àç i))) (lookup i vs)
            lem-03 i = Œª j -> map (execHom ex (valids30 _ _ _ (getEdge i) (~ j))) (lookup i vs)

            lem-04 : ‚àÄ(i : Fin-R (l a)) ->
                   map (execHom ex
                    (valids (lookup i ts .fst .snd)
                      (lookup i ts .snd , step p (incl a b0 vb0 vs wt ts i))))
                    (lookup i ts .fst .snd)
                    ‚â°
                    map (execHom ex (getElemSt‚ÇÅ (rtarget‚àç i)))
                    (lookup i ts .fst .snd)
            lem-04 i = Œª j -> map (execHom ex (valids31 _ _ _ (getEdge i) (~ j))) (lookup i ts .fst .snd)

            ts' : DVec (ANVecTree A l ‚Ñ¨ F WT bx) _
            ts' = makeFinalTrees ts (map-Vec (map f0) vs) (Œª i ‚Üí step p (incl a b0 vb0 vs wt ts i)) (Œª i ‚Üí lem-04 i ‚àô-‚â° sym-Path (lem-02 i) ‚àô-‚â° sym-Path (lem-03 i) ‚àô-‚â° sym-Path (comm-lookup-map  {i = i}))

-}
-}
-}
