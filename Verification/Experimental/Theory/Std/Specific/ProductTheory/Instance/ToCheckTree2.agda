
module Verification.Experimental.Theory.Std.Specific.ProductTheory.Instance.ToCheckTree2 where

open import Verification.Conventions hiding (_‚äî_ ; lookup)
open import Verification.Experimental.Set.Discrete
open import Verification.Experimental.Set.Contradiction
open import Verification.Experimental.Set.Setoid.Definition
open import Verification.Experimental.Set.Function.Surjective
open import Verification.Experimental.Data.Nat.Free
open import Verification.Experimental.Data.Sum.Definition
open import Verification.Experimental.Data.Product.Definition
open import Verification.Experimental.Data.Sum.Instance.Functor
open import Verification.Experimental.Category.Std.Monad.Definition
open import Verification.Experimental.Category.Std.Monad.KleisliCategory.Instance.Monoidal
open import Verification.Experimental.Category.Std.Monad.TypeMonadNotation
open import Verification.Experimental.Data.Sum.Instance.Monad
open import Verification.Experimental.Data.Universe.Everything
open import Verification.Experimental.Theory.Std.Specific.ProductTheory.Definition
open import Verification.Experimental.Theory.Std.Presentation.Token.Definition
open import Verification.Experimental.Category.Std.Category.Definition
open import Verification.Experimental.Category.Std.Functor.Definition
open import Verification.Experimental.Category.Std.Category.Subcategory.Definition
open import Verification.Experimental.Category.Std.Category.Subcategory.Full
open import Verification.Experimental.Data.Indexed.Definition
open import Verification.Experimental.Data.Indexed.Instance.Monoid
open import Verification.Experimental.Data.FiniteIndexed.Definition
open import Verification.Experimental.Algebra.Monoid.Definition
open import Verification.Experimental.Algebra.Monoid.Free
open import Verification.Experimental.Algebra.Monoid.Free.Element
open import Verification.Experimental.Data.Substitution.Definition
open import Verification.Experimental.Data.Substitution.Property.Base
open import Verification.Experimental.Theory.Std.Presentation.NGraph.Definition
open import Verification.Experimental.Category.Std.Limit.Specific.Coproduct.Definition
open import Verification.Experimental.Category.Std.Morphism.Iso

open import Verification.Experimental.Category.Std.RelativeMonad.Definition
open import Verification.Experimental.Category.Std.RelativeMonad.KleisliCategory.Definition


-- open import Verification.Experimental.Theory.Std.Specific.ProductTheory.Instance.FromString2
open import Verification.Experimental.Theory.Std.Presentation.CheckTree.Definition2
open import Verification.Experimental.Theory.Std.Specific.ProductTheory.Instance.FromANVecTree



module _ {A : ùí∞ ùëñ} {B : ùí∞ ùëó} where
  comm-lookup-map : ‚àÄ{f : A -> B} -> ‚àÄ{i : Fin-R n} -> ‚àÄ{as : Vec A n} -> lookup i (map-Vec f as) ‚â° f (lookup i as)
  comm-lookup-map = {!!}


module _ (A : ùí∞ ùëñ) (l : A -> ‚Ñï) where
  data VecTree1 : ùí∞ (ùëñ) where
    node1 : (a : A) -> (Vec VecTree1 (l a)) -> VecTree1
    -- node : (a : A) -> (‰∫∫Vec VecTree (l a)) -> VecTree
    -- var  : B -> VecTree

-- module _ {A : ùí∞ ùëñ} {l : A -> ‰∫∫‚Ñï' ùëñ} where
--   data TreeStep1 : (t s : VecTree1 A l) -> ùí∞ ùëñ where

--     incl : ‚àÄ{a : A} -> (ts : ([ l a ]·∂† -> (VecTree1 A l))) -> (i : [ l a ]·∂†)
--            -> TreeStep1 (node1 a ts) (ts i)

--   data TreePath1 : (t s : VecTree1 A l) -> ùí∞ (ùëñ) where
--     [] : ‚àÄ{t : VecTree1 A l} -> TreePath1 t t
--     step : ‚àÄ{r s t : (VecTree1 A l)} -> TreePath1 r s -> TreeStep1 s t -> TreePath1 r t


--   Vertex1 : (r : VecTree1 A l) -> ùí∞ _
--   Vertex1 r = ‚àë TreePath1 r

-- module _ {A : ùí∞ ùëñ} {l : A -> ‚Ñï} {‚Ñ¨ : ùí∞ ùëñ} {{_ : isCategory {ùëó} ‚Ñ¨}} {{_ : isSet-Str ‚Ñ¨}} {F : Functor ‚Ä≤ ‚Ñ¨ ‚Ä≤ (ùêîùêßùê¢ùêØ ùëô)} where
--   module _ (b : ‚Ñ¨) where
--     data isANVecTree : (‚ü® F ‚ü© b) -> ùí∞ (ùëñ ÔΩ§ ùëó ÔΩ§ ùëô) where
--       node1 : (a : A) -> (Vec VecTree1 (l a)) -> VecTree1


-- module _ {A : ùí∞ ùëñ} {B : ùí∞ ùëó} where
--   map-Vec : ‚àÄ{n} -> (f : A -> B) -> Vec A n -> Vec B n
--   map-Vec = ?

infixl 30 _‚àô-‚â°_
_‚àô-‚â°_ = trans-Path


module _ {A : ùí∞ ùëñ} {l : A -> ‚Ñï} {‚Ñ¨ : ùí∞ ùëñ} {{_ : isCategory {ùëó} ‚Ñ¨}} {{_ : isSet-Str ‚Ñ¨}} {F : Functor ‚Ä≤ ‚Ñ¨ ‚Ä≤ (ùêîùêßùê¢ùêØ ùëô)} {{_ : isCheckingBoundary ‚Ä≤ ‚Ñ¨ ‚Ä≤ F}} where

  module _ (initb : A -> ‚Ñ¨)
           (initv : ‚àÄ(a : A) -> ‚ü® F ‚ü© (initb a))
           (initvs : ‚àÄ(a : A) -> Vec (‚ü® F ‚ü© (initb a)) (l a))
           (WT : ‚àÄ{b} -> (a : A) -> ‚ü® F ‚ü© b -> Vec (‚ü® F ‚ü© b) (l a) -> ùí∞ ùëò)
           where

    mutual
      makeInitialTrees : ‚àÄ{n} -> Vec (VecTree1 A l) n -> Vec (‚àë ADANVecTree A l ‚Ñ¨ F WT) n
      makeInitialTrees ‚¶ã‚¶å = ‚¶ã‚¶å
      makeInitialTrees (x ‚à∑ ts) = (makeInitialTree x) ‚à∑ (makeInitialTrees ts)

      makeInitialTree : VecTree1 A l -> ‚àë ADANVecTree A l ‚Ñ¨ F WT
      makeInitialTree (node1 a x) = _ , (node1 a (initb a) (initv a) (initvs a) {!!} (makeInitialTrees x))

    mutual
      ibounds : ‰∫∫List ‚Ñ¨ -> Vec (VecTree1 A l) n -> ‰∫∫List ‚Ñ¨
      ibounds ac ‚¶ã‚¶å = ac
      ibounds ac (x ‚à∑ v) = ibounds (ac ‚ãÜ ibound x) v

      ibound : VecTree1 A l -> ‰∫∫List ‚Ñ¨
      ibound (node1 a x) = ibounds (incl (initb a)) x

    private
      lem-1 : ‚àÄ{a} -> {ac : ‰∫∫List ‚Ñ¨} -> (ts : Vec (VecTree1 A l) n) -> ac ‚àç a -> ibounds ac ts ‚àç a
      lem-1 ‚¶ã‚¶å p = p
      lem-1 (x ‚à∑ ts) p = lem-1 ts (left-‚àç p)

    mutual
      appendStrategy : ‚àÄ{as a} -> (s : Strategy as) -> (as ‚àç a) -> (vs : Vec (‚ü® F ‚ü© a) n) -> (v : Vec (VecTree1 A l) n) -> Strategy (ibounds as v)
      appendStrategy s as‚àça ‚¶ã‚¶å ‚¶ã‚¶å = s
      appendStrategy s as‚àça (v ‚à∑ vs) (t ‚à∑ ts) =
        let tstrat , trt = makeStrategy t
        in appendStrategy (resolve s tstrat (rtarget _ as‚àça v , trt)) (left-‚àç as‚àça) vs ts

      makeStrategy : (v : VecTree1 A l) -> (Strategy (ibound v) √ó ResolutionTarget (ibound v))
      makeStrategy (node1 a x) = appendStrategy (begin (initb a)) incl (initvs a) x , rt1
        where
          init‚àçb : ibounds (incl (initb a)) x ‚àç (initb a)
          init‚àçb = lem-1 x incl

          rt1 : ResolutionTarget (ibounds (incl (initb a)) x)
          rt1 = rtarget _ (init‚àçb) (initv a)


    isValidStrategy1 : ‚àÄ{as b} -> (t : ADANVecTree A l ‚Ñ¨ F WT b) -> (s : Strategy as) -> ùí∞ _
    isValidStrategy1 {as} {b} t _ = ‚àÄ{b1} -> (v1 : ‚ü® F ‚ü© b1) -> (ADANVertex A l ‚Ñ¨ F WT) v1 (_ , t) -> as ‚àç b1

    isValidStrategy2 : ‚àÄ{as b} -> (t : ADANVecTree A l ‚Ñ¨ F WT b) -> (s : Strategy as) -> ùí∞ _
    isValidStrategy2 t s = ‚àÄ{b1 b2} -> (v1 : ‚ü® F ‚ü© b1) (v2 : ‚ü® F ‚ü© b2) (vout : ‚ü® F ‚ü© b1)-> (ADANEdge A l ‚Ñ¨ F WT) v1 v2 vout (_ , t) -> s ‚àç-St‚ÇÇ (rtarget b1 vout , rtarget b2 v2)

    isValidStrategy3‚ÇÄ : ‚àÄ{as b} -> (t : ADANVecTree A l ‚Ñ¨ F WT b) -> (s : Strategy as)
                       -> (valid1 : isValidStrategy1 t s) -> (valid2 : isValidStrategy2 t s) -> ùí∞ _
    isValidStrategy3‚ÇÄ t s valid1 valid2 = ‚àÄ{b1 b2} -> (v1 : ‚ü® F ‚ü© b1) (v2 : ‚ü® F ‚ü© b2) (vout : ‚ü® F ‚ü© b1)-> (e : (ADANEdge A l ‚Ñ¨ F WT) v1 v2 vout (_ , t))
                                 -> getElemSt‚ÇÄ (valid2 v1 v2 vout e) ‚â° valid1 v1 (e .fst , e .snd .snd .fst)

    isValidStrategy3‚ÇÅ : ‚àÄ{as b} -> (t : ADANVecTree A l ‚Ñ¨ F WT b) -> (s : Strategy as)
                       -> (valid1 : isValidStrategy1 t s) -> (valid2 : isValidStrategy2 t s) -> ùí∞ _
    isValidStrategy3‚ÇÅ t s valid1 valid2 = ‚àÄ{b1 b2} -> (v1 : ‚ü® F ‚ü© b1) (v2 : ‚ü® F ‚ü© b2) (vout : ‚ü® F ‚ü© b1)-> (e : (ADANEdge A l ‚Ñ¨ F WT) v1 v2 vout (_ , t))
                                 -> getElemSt‚ÇÅ (valid2 v1 v2 vout e) ‚â° valid1 v2 ((e .snd .fst) , (step (e .snd .snd .fst) (e .snd .snd .snd))) -- (e .fst , e .snd .snd .fst)

    -- we show that `makeStrategy` creates a valid strategy

    module _ (t : VecTree1 A l) where
      valid1:makeStrategy : isValidStrategy1 (makeInitialTree t .snd) (makeStrategy t .fst)
      valid1:makeStrategy = P t
        where
          -- ibounds : ‰∫∫List ‚Ñ¨ -> Vec (VecTree1 A l) n -> ‰∫∫List ‚Ñ¨
          -- (t : VecTree1 A l) -> ‚àÄ{b1} -> (v1 : ‚ü® F ‚ü© b1) -> (ADANVertex A l ‚Ñ¨ F WT) v1 (makeInitialTree t) -> ibound t ‚àç b1

          Ps0 : {ac : ‰∫∫List ‚Ñ¨} -> ‚àÄ{a} -> (ac ‚àç a) -> (ts : Vec (VecTree1 A l) n) -> ibounds (ac) ts ‚àç a
          Ps0 p ‚¶ã‚¶å = p
          Ps0 p (x ‚à∑ ts) = Ps0 (left-‚àç p) ts

          Ps : {ac : ‰∫∫List ‚Ñ¨} -> ‚àÄ{b1} -> (ts : Vec (VecTree1 A l) n) -> (i : Fin-R n) -> ibounds ac ts ‚àç b1
          Ps t = {!!}

          P0 : (t : VecTree1 A l) -> ibound t ‚àç (makeInitialTree t .fst .fst)
          P0 (node1 a x) = Ps0 incl x

          -- Pstep : ‚àÄ{b} -> (t s : VecTree1 A l) -> ‚àÄ{vout}
          --              -> ADANTreeStep A l ‚Ñ¨ F WT (makeInitialTree t) (makeInitialTree s) vout
          --              -> ibound s ‚àç b -> ibound t ‚àç b

          Pstep : ‚àÄ{b} -> (t' s' : ‚àë ADANVecTree A l ‚Ñ¨ F WT)
                       -> (t s : VecTree1 A l)
                       -> (makeInitialTree t ‚â° t') -> (makeInitialTree s ‚â° s')
                       -> ‚àÄ{vout}
                       -> ADANTreeStep A l ‚Ñ¨ F WT (t') (s') vout
                       -> ibound s ‚àç b -> ibound t ‚àç b
          Pstep .((b , v) , node1 a b v vs wt ts) .(lookup i ts) t s ptt pss (incl a b v vs wt ts i) bm = {!!}

          P : (t : VecTree1 A l) -> ‚àÄ{b1} -> (v1 : ‚ü® F ‚ü© b1) -> (ADANVertex A l ‚Ñ¨ F WT) v1 (makeInitialTree t) -> ibound t ‚àç b1
          P (node1 a x) .(snd (fst (makeInitialTree (node1 a x)))) (.(snd (makeInitialTree (node1 a x))) , []) = Ps0 incl x
          P (node1 a ts) v1 (t-next , step p s) = {!!}
          -- Ps ts {!!}


{-
    module _ {as tb} (t : ADANVecTree A l ‚Ñ¨ F WT tb) (s : Strategy as)
             (valids : isValidStrategy1 t s) (valids2 : isValidStrategy2 t s)
             (valids30 : isValidStrategy3‚ÇÄ t s valids valids2)
             (valids31 : isValidStrategy3‚ÇÅ t s valids valids2)
             {bx} (ex : Execution s bx) (exCorrect : isCorrect ex) where


      mutual
        makeFinalTrees : ‚àÄ{n} -> (ts : Vec (‚àë ADANVecTree A l ‚Ñ¨ F WT) n) -> (vs : Vec (‚ü® F ‚ü© bx) n)
                              -> (p : ‚àÄ(i : Fin-R n) -> ADANTreePath A l ‚Ñ¨ F WT (_ , t) (lookup i ts))

                              -> (‚àÄ(i : Fin-R n) -> map (execHom ex
                                                                 (valids (lookup i ts .fst .snd)
                                                                         (lookup i ts .snd , p i)))
                                                        (lookup i ts .fst .snd)
                                                    ‚â°
                                                    lookup i vs
                                 )
                              -> DVec (ANVecTree A l ‚Ñ¨ F WT bx) vs
        makeFinalTrees ‚¶ã‚¶å ‚¶ã‚¶å ps pP = []
        makeFinalTrees ((_ , t) ‚à∑ ts) (v ‚à∑ vs) ps pP = t1 ‚à∑ (makeFinalTrees ts vs (Œª i -> ps (suc i)) (Œª i -> pP (suc i)))
          where
            t0 = makeFinalTree _ t (ps zero)

            t1 : ANVecTree A l ‚Ñ¨ F WT bx v
            t1 = transport (Œª i -> ANVecTree A l ‚Ñ¨ F WT bx (pP zero i)) t0


        makeFinalTree : ‚àÄ{b0} -> (vb0 : ‚ü® F ‚ü© b0) (s : ADANVecTree A l ‚Ñ¨ F WT (b0 , vb0)) -> (p : ADANTreePath A l ‚Ñ¨ F WT (_ , t) (_ , s)) -> ANVecTree A l ‚Ñ¨ F WT bx (map (execHom ex (valids vb0 (s , p))) vb0)
        makeFinalTree {b0} vb0 curtree@(node1 a .b0 .vb0 vs wt ts) p = (node1 a (map f0 vb0) (map-Vec (map f0) vs) {!!} ts')
          where
            sb‚àçb : as ‚àç b0
            sb‚àçb = (valids vb0 (((node1 a b0 vb0 vs wt ts)) , p))

            f0 : b0 ‚ü∂ bx
            f0 = execHom ex sb‚àçb

            getEdge : ‚àÄ(i : Fin-R (l a)) -> ADANEdge A l ‚Ñ¨ F WT vb0 (lookup i ts .fst .snd) (lookup i vs) (_ , t)
            getEdge i = ((node1 a b0 vb0 vs wt ts)) , (lookup i ts .snd , p , (incl a b0 vb0 vs wt ts i))

            rtarget‚àç : ‚àÄ(i : Fin-R (l a)) -> s ‚àç-St‚ÇÇ (rtarget _ (lookup i vs) , rtarget _ (lookup i ts .fst .snd))
            rtarget‚àç i = valids2 _ _ _ (getEdge i)

            lem-02 : ‚àÄ(i : Fin-R (l a))
                    -> map (execHom ex (getElemSt‚ÇÄ (rtarget‚àç i))) (lookup i vs) ‚â° map (execHom ex (getElemSt‚ÇÅ (rtarget‚àç i))) (lookup i ts .fst .snd)
            lem-02 i = exCorrect _ (rtarget‚àç i)

            lem-03 :  ‚àÄ(i : Fin-R (l a))
                    -> map (execHom ex (valids vb0 (curtree , p))) (lookup i vs) ‚â° map (execHom ex (getElemSt‚ÇÄ (rtarget‚àç i))) (lookup i vs)
            lem-03 i = Œª j -> map (execHom ex (valids30 _ _ _ (getEdge i) (~ j))) (lookup i vs)

            lem-04 : ‚àÄ(i : Fin-R (l a)) ->
                   map (execHom ex
                    (valids (lookup i ts .fst .snd)
                      (lookup i ts .snd , step p (incl a b0 vb0 vs wt ts i))))
                    (lookup i ts .fst .snd)
                    ‚â°
                    map (execHom ex (getElemSt‚ÇÅ (rtarget‚àç i)))
                    (lookup i ts .fst .snd)
            lem-04 i = Œª j -> map (execHom ex (valids31 _ _ _ (getEdge i) (~ j))) (lookup i ts .fst .snd)

            ts' : DVec (ANVecTree A l ‚Ñ¨ F WT bx) _
            ts' = makeFinalTrees ts (map-Vec (map f0) vs) (Œª i ‚Üí step p (incl a b0 vb0 vs wt ts i)) (Œª i ‚Üí lem-04 i ‚àô-‚â° sym-Path (lem-02 i) ‚àô-‚â° sym-Path (lem-03 i) ‚àô-‚â° sym-Path (comm-lookup-map  {i = i}))

-}

