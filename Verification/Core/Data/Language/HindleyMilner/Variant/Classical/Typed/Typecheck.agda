
module Verification.Core.Data.Language.HindleyMilner.Variant.Classical.Typed.Typecheck where

open import Verification.Conventions hiding (lookup ; ‚Ñï ; _‚äî_)
open import Verification.Core.Set.Setoid.Definition
open import Verification.Core.Set.Discrete
open import Verification.Core.Algebra.Monoid.Definition
open import Verification.Core.Algebra.Monoid.Free
open import Verification.Core.Data.AllOf.Collection.Basics
open import Verification.Core.Data.AllOf.Collection.TermTools
open import Verification.Core.Category.Std.AllOf.Collection.Basics
open import Verification.Core.Category.Std.AllOf.Collection.Limits
open import Verification.Core.Computation.Unification.Definition
open import Verification.Core.Category.Std.AllOf.Collection.Monads
-- open import Verification.Core.Category.Std.Fibration.GrothendieckConstruction.Definition

open import Verification.Core.Theory.Std.Specific.ProductTheory.Module
open import Verification.Core.Theory.Std.Specific.ProductTheory.Instance.hasBoundaries

open import Verification.Core.Data.Language.HindleyMilner.Type.Definition
open import Verification.Core.Data.Language.HindleyMilner.Variant.Classical.Typed.Definition
open import Verification.Core.Data.Language.HindleyMilner.Variant.Classical.Typed.Proofs
open import Verification.Core.Data.Language.HindleyMilner.Variant.Classical.Untyped.Definition
open import Verification.Core.Data.Language.HindleyMilner.Helpers

open import Verification.Core.Category.Std.Limit.Specific.Coequalizer
open import Verification.Core.Set.Decidable

open import Verification.Core.Category.Std.RelativeMonad.KleisliCategory.Definition



record _<Œì_ {k} {Q : ‚ÑíHMQuant k} {Œºs ŒΩs} (Œì : ‚ÑíHMCtxFor Q Œºs) (Œì' : ‚ÑíHMCtxFor Q ŒΩs) : ùí∞‚ÇÄ where
  field fst : Œºs ‚ü∂ ŒΩs
  field snd : Œì ‚áÉ[ fst ]‚áÇ-CtxFor ‚â° Œì'
open _<Œì_ public

record CtxTypingInstance {Œºs k} {Q : ‚ÑíHMQuant k} (Œì : ‚ÑíHMCtxFor Q Œºs) (te : Untyped‚ÑíHM k) : ùí∞‚ÇÄ where
  constructor _‚ä©_,_,_,_
  field metas : ‚ÑíHMTypes
  field ctx : ‚ÑíHMCtxFor Q metas
  field typ : ‚ÑíHMType (‚ü® metas ‚ü©)
  field isInstance : Œì <Œì ctx
  field hasType : isTyped‚ÑíHM (metas ‚ä© (Q , ctx) ‚ä¢ typ) te

open CtxTypingInstance public


module _ {Œºs k} {Q : ‚ÑíHMQuant k} {Œì : ‚ÑíHMCtxFor Q Œºs} {te : Untyped‚ÑíHM k}  where
  record _<TI_ (ùëá ùëÜ : CtxTypingInstance Œì te) : ùí∞‚ÇÄ where
    field tiSub : metas ùëá ‚ü∂ metas ùëÜ
    field typProof : typ ùëá ‚áÉ[ tiSub ]‚áÇ ‚â° typ ùëÜ
    field subProof : isInstance ùëá .fst ‚óÜ tiSub ‚àº isInstance ùëÜ .fst

    ctxProofTI : ctx ùëá ‚áÉ[ tiSub ]‚áÇ-CtxFor ‚â° ctx ùëÜ
    ctxProofTI = {!!}

  open _<TI_ public

InitialCtxTypingInstance : ‚àÄ{Œºs k} -> {Q : ‚ÑíHMQuant k} -> (Œì : ‚ÑíHMCtxFor Q Œºs) (te : Untyped‚ÑíHM k) -> ùí∞‚ÇÄ
InitialCtxTypingInstance Œì te = ‚àë Œª (ùëá : CtxTypingInstance Œì te) -> ‚àÄ(ùëÜ : CtxTypingInstance Œì te) -> ùëá <TI ùëÜ


Œ≥ : ‚àÄ{Œºs k} {Q : ‚ÑíHMQuant k} -> (Œì : ‚ÑíHMCtxFor Q Œºs) -> (te : Untyped‚ÑíHM k)
  -> (CtxTypingInstance Œì te -> ‚ä•-ùí∞ {‚Ñì‚ÇÄ})
    +
     (InitialCtxTypingInstance Œì te)
Œ≥ {Œºs} {k} {Q} Œì (var k‚àçi) = {!!}
{-
  let vŒ± = lookup-DList Q k‚àçi
      Œ± = lookup-DDList Œì k‚àçi
      œÉ·µ§‚ÇÄ : Œºs ‚ü∂ Œºs ‚äî vŒ±
      œÉ·µ§‚ÇÄ = Œπ‚ÇÄ

      Œ±‚ÇÄ = Œ± ‚áÉ[ id ‚áÉ‚äî‚áÇ id ]‚áÇ

      Œì‚ÇÄ = Œì ‚áÉ[ Œπ‚ÇÄ ]‚áÇ-CtxFor

      Œì<Œì‚ÇÄ : Œì <Œì Œì‚ÇÄ
      Œì<Œì‚ÇÄ = record { fst = œÉ·µ§‚ÇÄ ; snd = refl-‚â° }

  in right (((Œºs ‚äî vŒ±) ‚ä© Œì‚ÇÄ , Œ±‚ÇÄ , Œì<Œì‚ÇÄ , var k‚àçi refl-‚â£ id)

           -- now we have to prove that this is the "initial" such typing instance
           , Œª {(.(Œºs‚ÇÅ ‚äî vŒ±‚ÇÅ) ‚ä© Œì‚ÇÅ , Œ±‚ÇÅ , Œì<Œì‚ÇÅ , var {Œºs = Œºs‚ÇÅ} {Œì = Œì‚ÇÅ'} _ {vŒ±' = vŒ±‚ÇÅ} refl-‚â£ œÅ) ‚Üí

               -- given another instance, which has to use `var` to prove the typing

                let œÉ·µ§‚ÇÅ : Œºs ‚ü∂ Œºs‚ÇÅ ‚äî vŒ±‚ÇÅ
                    œÉ·µ§‚ÇÅ = Œì<Œì‚ÇÅ .fst

                    œÉ‚ÇÄ‚ÇÅ : Œºs ‚äî vŒ± ‚ü∂ Œºs‚ÇÅ ‚äî vŒ±‚ÇÅ
                    œÉ‚ÇÄ‚ÇÅ = ‚¶ó œÉ·µ§‚ÇÅ , (œÅ ‚óÜ Œπ‚ÇÅ) ‚¶ò

                    --------------------------------------
                    -- next, we need to show that this
                    -- substitution recreates the given Œî and Œ¥

                    -------------
                    -- i) for œÉ‚ÇÄ‚ÇÅ
                    -------------

                    lem-10 : œÉ·µ§‚ÇÄ ‚óÜ œÉ‚ÇÄ‚ÇÅ ‚àº œÉ·µ§‚ÇÅ
                    lem-10 = reduce-Œπ‚ÇÄ {g = œÅ ‚óÜ Œπ‚ÇÅ}

                    -------------
                    -- ii) for Œ±‚ÇÄ
                    -------------

                    lem-11 : Œ±‚ÇÄ ‚â° Œ±
                    lem-11 = Œ± ‚áÉ[ id ‚áÉ‚äî‚áÇ id ]‚áÇ    ‚ü® Œ± ‚áÉ[‚âÄ functoriality-id-‚äî ‚âÄ]‚áÇ ‚ü©-‚â°
                              Œ± ‚áÉ[ id ]‚áÇ           ‚ü® functoriality-id-‚áÉ[]‚áÇ {œÑ = Œ±} ‚ü©-‚â°
                              Œ±                    ‚àé-‚â°

                    lem-12 : Œ±‚ÇÄ ‚áÉ[ œÉ‚ÇÄ‚ÇÅ ]‚áÇ ‚â° lookup-DDList Œì‚ÇÅ k‚àçi ‚áÉ[ ‚¶ó id , œÅ ‚óÜ Œπ‚ÇÅ ‚¶ò ]‚áÇ
                    lem-12 = Œ± ‚áÉ[ id ‚áÉ‚äî‚áÇ id ]‚áÇ ‚áÉ[ œÉ‚ÇÄ‚ÇÅ ]‚áÇ     ‚ü® cong _‚áÉ[ œÉ‚ÇÄ‚ÇÅ ]‚áÇ lem-11 ‚ü©-‚â°
                              lookup-DDList Œì k‚àçi ‚áÉ[ ‚¶ó œÉ·µ§‚ÇÅ , œÅ ‚óÜ Œπ‚ÇÅ ‚¶ò ]‚áÇ  ‚ü® sym-Path (¬ß-‚ÑíHMCtx.prop-2 {Œì = Œì} k‚àçi œÉ·µ§‚ÇÅ (œÅ ‚óÜ Œπ‚ÇÅ)) ‚ü©-‚â°
                              lookup-DDList (Œì ‚áÉ[ œÉ·µ§‚ÇÅ ]‚áÇ-CtxFor) k‚àçi ‚áÉ[ ‚¶ó id , œÅ ‚óÜ Œπ‚ÇÅ ‚¶ò ]‚áÇ

                              ‚ü® (Œª i -> lookup-DDList (Œì<Œì‚ÇÅ .snd i ) k‚àçi ‚áÉ[ ‚¶ó id , œÅ ‚óÜ Œπ‚ÇÅ ‚¶ò ]‚áÇ) ‚ü©-‚â°

                              lookup-DDList Œì‚ÇÅ k‚àçi ‚áÉ[ ‚¶ó id , œÅ ‚óÜ Œπ‚ÇÅ ‚¶ò ]‚áÇ                     ‚àé-‚â°


                    lem-15 : Œì‚ÇÅ' ‚áÉ[ id ‚óÜ Œπ‚ÇÄ ]‚áÇ-CtxFor ‚â° Œì‚ÇÅ
                    lem-15 = Œì‚ÇÅ' ‚áÉ[ id ‚óÜ Œπ‚ÇÄ ]‚áÇ-CtxFor  ‚ü® Œì‚ÇÅ' ‚áÉ[‚âÄ unit-l-‚óÜ ‚âÄ]‚áÇ-CtxFor ‚ü©-‚â°
                             Œì‚ÇÅ' ‚áÉ[ Œπ‚ÇÄ ]‚áÇ-CtxFor       ‚àé-‚â°

                    lem-16 : Œ±‚ÇÅ ‚â° lookup-DDList Œì‚ÇÅ k‚àçi ‚áÉ[ ‚¶ó id , œÅ ‚óÜ Œπ‚ÇÅ ‚¶ò ]‚áÇ
                    lem-16 = lookup-DDList Œì‚ÇÅ' k‚àçi ‚áÉ[ ‚¶ó id ‚óÜ Œπ‚ÇÄ , œÅ ‚óÜ Œπ‚ÇÅ ‚¶ò ]‚áÇ   ‚ü® sym-Path (¬ß-‚ÑíHMCtx.prop-2 {Œì = Œì‚ÇÅ'} k‚àçi (id ‚óÜ Œπ‚ÇÄ) (œÅ ‚óÜ Œπ‚ÇÅ)) ‚ü©-‚â°
                              lookup-DDList (Œì‚ÇÅ' ‚áÉ[ id ‚óÜ Œπ‚ÇÄ ]‚áÇ-CtxFor) k‚àçi ‚áÉ[ ‚¶ó id , œÅ ‚óÜ Œπ‚ÇÅ ‚¶ò ]‚áÇ

                              ‚ü® (Œª i -> lookup-DDList (lem-15 i) k‚àçi ‚áÉ[ ‚¶ó id , œÅ ‚óÜ Œπ‚ÇÅ ‚¶ò ]‚áÇ) ‚ü©-‚â°

                              lookup-DDList (Œì‚ÇÅ) k‚àçi ‚áÉ[ ‚¶ó id , œÅ ‚óÜ Œπ‚ÇÅ ‚¶ò ]‚áÇ                       ‚àé-‚â°

                    lem-20 : Œ±‚ÇÄ ‚áÉ[ œÉ‚ÇÄ‚ÇÅ ]‚áÇ ‚â° Œ±‚ÇÅ
                    lem-20 = trans-Path lem-12 (sym-Path lem-16)

                in record { tiSub = œÉ‚ÇÄ‚ÇÅ ; typProof = lem-20 ; subProof = lem-10 }

               })
-}
Œ≥ Œì (slet te se) with Œ≥ Œì te
... | (left _) = {!!}
... | (right ((ŒΩs‚ÇÄ ‚ä© Œì‚ÇÄ , œÑ‚ÇÄ , Œì‚ÇÄ<Œì , Œì‚ÇÄ‚ä¢œÑ‚ÇÄ), Œû)) = {!!}
{-
  let ŒΩs‚ÇÄ' , Œì‚ÇÄ' , œÑ‚ÇÄ' , isAb = abstr-Ctx Œì‚ÇÄ‚ä¢œÑ‚ÇÄ

      œï = metasProof isAb

      Œ∫s = œÑ‚ÇÄ' .fst

      -- add the type œÑ‚ÇÄ' to the context
      -- and typecheck se
      x = Œ≥ (œÑ‚ÇÄ' ‚à∑ Œì‚ÇÄ') se

  in case x of
        {!!}

        -- if we get a good result
        Œª {(Œºs ‚ä© (œÑ‚ÇÅ ‚à∑ Œì‚ÇÅ) , Œ≤ , Œì‚ÇÅ<œÑ‚ÇÄŒì , Œì‚ÇÅ‚ä¢œÑ‚ÇÅ) ‚Üí

          let œÉ = fst Œì‚ÇÅ<œÑ‚ÇÄŒì

              Œì‚ÇÄv = Œì‚ÇÄ ‚áÉ[ ‚ü® œï ‚ü©‚Åª¬π ‚óÜ (œÉ ‚áÉ‚äî‚áÇ id) ]‚áÇ-Ctx
              œÑ‚ÇÄv = œÑ‚ÇÄ ‚áÉ[ ‚ü® œï ‚ü©‚Åª¬π ‚óÜ (œÉ ‚áÉ‚äî‚áÇ id) ]‚áÇ

              tepv : isTyped‚ÑíHM ((Œºs ‚äî Œπ Œ∫s) ‚ä© Œì‚ÇÄv ‚ä¢ œÑ‚ÇÄv) te
              tepv = ¬ß-isTyped‚ÑíHM.prop-2 _ Œì‚ÇÄ‚ä¢œÑ‚ÇÄ

              abPv : isAbstr (Œπ (œÑ‚ÇÅ .fst)) Œì‚ÇÄv Œì‚ÇÅ œÑ‚ÇÄv (œÑ‚ÇÅ .snd)
              abPv =
                let
                    lem-1 : Œºs ‚äî Œπ (œÑ‚ÇÅ .fst) ‚âÖ (Œºs ‚äî Œπ Œ∫s)
                    lem-1 = {!!} -- but we know that actually Œπ (œÑ‚ÇÅ.fst) ‚â° Œπ Œ∫s
                                 -- since they both come from the quantified part of the context
                in record { metasProof = lem-1 ; ctxProof = {!!} ; typeProof = {!!} }

          in right (Œºs ‚ä© Œì‚ÇÅ , Œ≤ , {!!} , slet abPv tepv Œì‚ÇÅ‚ä¢œÑ‚ÇÅ)
        }
-}
-- the case of an application
-- typecheck the first term with the given context
Œ≥ {Œºs = ŒΩs} Œì (app te se) = {!!}
{-
with Œ≥ Œì te
... | (left _) = {!!}
... | (right ((ŒΩs‚ÇÄ ‚ä© Œì‚ÇÄ , Œ±‚ÇÄ , Œì<Œì‚ÇÄ , Œì‚ÇÄ‚ä¢Œ±‚ÇÄ), Œ©‚ÇÄ)) with Œ≥ Œì‚ÇÄ se
... | (left _) = {!!}
... | (right ((ŒΩs‚ÇÅ ‚ä© Œì‚ÇÅ , Œ≤‚ÇÅ , Œì‚ÇÄ<Œì‚ÇÅ , Œì‚ÇÅ‚ä¢Œ≤‚ÇÅ), Œ©‚ÇÅ)) = resn
  where

    œÉ·µ§‚ÇÄ : _ ‚ü∂ ŒΩs‚ÇÄ
    œÉ·µ§‚ÇÄ = fst Œì<Œì‚ÇÄ

    -- lift the œÑ0 typing to Œì‚ÇÅ
    œÉ‚ÇÄ‚ÇÅ : ŒΩs‚ÇÄ ‚ü∂ ŒΩs‚ÇÅ
    œÉ‚ÇÄ‚ÇÅ = fst Œì‚ÇÄ<Œì‚ÇÅ

    -- we lift Œ±‚ÇÄ to the metas ŒΩs‚ÇÅ
    -- œÑ‚ÇÄ'
    Œ±‚ÇÅ : ‚ÑíHMType _
    Œ±‚ÇÅ = Œ±‚ÇÄ ‚áÉ[ œÉ‚ÇÄ‚ÇÅ ]‚áÇ

    -- we need a new type variable for the return
    -- type of the application, so we move to ŒΩs‚ÇÇ
    ŒΩs‚ÇÇ = (ŒΩs‚ÇÅ) ‚äî st
    œÉ‚ÇÅ‚ÇÇ : ŒΩs‚ÇÅ ‚ü∂ ŒΩs‚ÇÇ
    œÉ‚ÇÅ‚ÇÇ = Œπ‚ÇÄ

    -- œÑ‚ÇÄ''
    Œ±‚ÇÇ : ‚ÑíHMType ‚ü® ŒΩs‚ÇÇ ‚ü©
    Œ±‚ÇÇ = Œ±‚ÇÅ ‚áÉ[ œÉ‚ÇÅ‚ÇÇ ]‚áÇ

    Œ≤‚ÇÇ : ‚ÑíHMType ‚ü® ŒΩs‚ÇÇ ‚ü©
    Œ≤‚ÇÇ = Œ≤‚ÇÅ ‚áÉ[ œÉ‚ÇÅ‚ÇÇ ]‚áÇ

    -- Œì‚ÇÅ'
    Œì‚ÇÇ = Œì‚ÇÅ ‚áÉ[ œÉ‚ÇÅ‚ÇÇ ]‚áÇ-Ctx

    -- we call the new type Œ≥
    Œ≥‚ÇÇ : ‚ÑíHMType ‚ü® ŒΩs‚ÇÇ ‚ü©
    Œ≥‚ÇÇ = var (right-‚àç incl)

    -- the types which we unify are:
    u : ‚ÑíHMType ‚ü® ŒΩs‚ÇÇ ‚ü©
    u = Œ±‚ÇÇ

    v : ‚ÑíHMType ‚ü® ŒΩs‚ÇÇ ‚ü©
    v = Œ≤‚ÇÇ ‚áí Œ≥‚ÇÇ

    res = unify-‚ÑíHMTypes (asArr u) (asArr v)

    resn = case res of
           {!!}
           Œª x ‚Üí
             let ŒΩs‚ÇÉ = ‚ü® x ‚ü©
                 œÉ‚ÇÇ‚ÇÉ : ŒΩs‚ÇÇ ‚ü∂ ŒΩs‚ÇÉ
                 œÉ‚ÇÇ‚ÇÉ = œÄ‚Çå

                 Œ≤‚ÇÉ = Œ≤‚ÇÇ ‚áÉ[ œÉ‚ÇÇ‚ÇÉ ]‚áÇ
                 Œì‚ÇÉ = Œì‚ÇÇ ‚áÉ[ œÉ‚ÇÇ‚ÇÉ ]‚áÇ-Ctx

                 -- thus the full substitution we need is the following
                 œÉ·µ§‚ÇÉ = œÉ·µ§‚ÇÄ ‚óÜ œÉ‚ÇÄ‚ÇÅ ‚óÜ œÉ‚ÇÅ‚ÇÇ ‚óÜ œÉ‚ÇÇ‚ÇÉ

                 Œì<Œì‚ÇÉ : Œì <Œì Œì‚ÇÉ
                 Œì<Œì‚ÇÉ = record { fst = œÉ·µ§‚ÇÉ ; snd = {!!} }

{-
                 -- move the typing of se to Œì‚ÇÇ = Œì‚ÇÅ[ Œπ‚ÇÄ ‚óÜ œÉ ]
                 sp : isTyped‚ÑíHM (ŒΩs‚ÇÇ ‚ä© (Œì‚ÇÅ ‚áÉ[ Œπ‚ÇÄ ]‚áÇ-Ctx) ‚ä¢ (œÑ‚ÇÅ ‚áÉ[ Œπ‚ÇÄ ]‚áÇ)) se
                 sp = ¬ß-isTyped‚ÑíHM.prop-2 Œπ‚ÇÄ Œì‚ÇÅ‚ä¢œÑ‚ÇÅ

                 sp' : isTyped‚ÑíHM (‚ü® x ‚ü© ‚ä© (Œì‚ÇÅ ‚áÉ[ Œπ‚ÇÄ ]‚áÇ-Ctx ‚áÉ[ œÉ ]‚áÇ-Ctx) ‚ä¢ (œÑ‚ÇÅ ‚áÉ[ Œπ‚ÇÄ ]‚áÇ ‚áÉ[ œÉ ]‚áÇ)) se
                 sp' = ¬ß-isTyped‚ÑíHM.prop-2 œÉ sp

                 -- move the typing of te to Œì‚ÇÇ = Œì‚ÇÄ[ œÉ·µ§‚ÇÄ ‚óÜ Œπ‚ÇÄ ‚óÜ œÉ ]
                 tp : isTyped‚ÑíHM (ŒΩs‚ÇÅ ‚ä© Œì‚ÇÅ ‚ä¢ (œÑ‚ÇÄ ‚áÉ[ œÉ·µ§‚ÇÄ ]‚áÇ)) te
                 tp = {!!}

                 tp' : isTyped‚ÑíHM (ŒΩs‚ÇÇ ‚ä© (Œì‚ÇÅ ‚áÉ[ Œπ‚ÇÄ ]‚áÇ-Ctx) ‚ä¢ (œÑ‚ÇÄ ‚áÉ[ œÉ·µ§‚ÇÄ ]‚áÇ ‚áÉ[ Œπ‚ÇÄ ]‚áÇ)) te
                 tp' = ¬ß-isTyped‚ÑíHM.prop-2 Œπ‚ÇÄ tp

                 tp'' : isTyped‚ÑíHM (‚ü® x ‚ü© ‚ä© (Œì‚ÇÅ ‚áÉ[ Œπ‚ÇÄ ]‚áÇ-Ctx ‚áÉ[ œÉ ]‚áÇ-Ctx) ‚ä¢ (œÑ‚ÇÄ ‚áÉ[ œÉ·µ§‚ÇÄ ]‚áÇ ‚áÉ[ Œπ‚ÇÄ ]‚áÇ ‚áÉ[ œÉ ]‚áÇ)) te
                 tp'' = ¬ß-isTyped‚ÑíHM.prop-2 œÉ tp'

                 tp''' : isTyped‚ÑíHM (‚ü® x ‚ü© ‚ä© (Œì‚ÇÅ ‚áÉ[ Œπ‚ÇÄ ]‚áÇ-Ctx ‚áÉ[ œÉ ]‚áÇ-Ctx) ‚ä¢ (œÑ‚ÇÅ ‚áÉ[ Œπ‚ÇÄ ]‚áÇ ‚áÉ[ œÉ ]‚áÇ ‚áí Œ≤ ‚áÉ[ œÉ ]‚áÇ)) te
                 tp''' = {!!}
-}

             in right ((ŒΩs‚ÇÉ ‚ä© Œì‚ÇÉ , Œ≤‚ÇÉ , Œì<Œì‚ÇÉ , {!!} ), -- app tp''' sp'),
                      Œª {(ŒΩs‚ÇÑ ‚ä© Œû , Œæ , Œì<Œû , app {Œ± = Œæ‚ÇÑ} {Œ≤ = Œ∂‚ÇÑ} Œû‚ä¢Œæ‚áíŒ∂ Œû‚ä¢Œæ) ->
                        let œÉ·µ§‚ÇÑ : ŒΩs ‚ü∂ ŒΩs‚ÇÑ
                            œÉ·µ§‚ÇÑ = fst Œì<Œû

                            Œ©R‚ÇÄ = Œ©‚ÇÄ (ŒΩs‚ÇÑ ‚ä© Œû , (Œæ‚ÇÑ ‚áí Œ∂‚ÇÑ) , Œì<Œû , Œû‚ä¢Œæ‚áíŒ∂)

                            œÉ‚ÇÄ‚ÇÑ : ŒΩs‚ÇÄ ‚ü∂ ŒΩs‚ÇÑ
                            œÉ‚ÇÄ‚ÇÑ = tiSub Œ©R‚ÇÄ

                            Œì‚ÇÄ<Œû : Œì‚ÇÄ <Œì Œû
                            Œì‚ÇÄ<Œû = record { fst = œÉ‚ÇÄ‚ÇÑ ; snd = ctxProof Œ©R‚ÇÄ }

                            Œ©R‚ÇÅ = Œ©‚ÇÅ (ŒΩs‚ÇÑ ‚ä© Œû , Œæ‚ÇÑ , Œì‚ÇÄ<Œû , Œû‚ä¢Œæ)

                            œÉ‚ÇÅ‚ÇÑ : ŒΩs‚ÇÅ ‚ü∂ ŒΩs‚ÇÑ
                            œÉ‚ÇÅ‚ÇÑ = tiSub Œ©R‚ÇÅ

                            -- we can build a substitution from ŒΩs‚ÇÇ by mapping Œ≥ to Œ∂‚ÇÑ
                            œÉ‚ÇÇ‚ÇÑ : ŒΩs‚ÇÇ ‚ü∂ ŒΩs‚ÇÑ
                            œÉ‚ÇÇ‚ÇÑ = ‚¶ó œÉ‚ÇÅ‚ÇÑ , ‚ßúsubst (incl Œ∂‚ÇÑ) ‚¶ò

                            -- we know that under this substitution,
                            -- u = Œ±‚ÇÇ and v = Œ≤‚ÇÇ ‚áí Œ≥‚ÇÇ become both Œæ‚áíŒ∂
                            lem-1 : u ‚áÉ[ œÉ‚ÇÇ‚ÇÑ ]‚áÇ ‚â° Œæ‚ÇÑ ‚áí Œ∂‚ÇÑ
                            lem-1 = Œ±‚ÇÅ ‚áÉ[ Œπ‚ÇÄ ]‚áÇ ‚áÉ[ œÉ‚ÇÇ‚ÇÑ ]‚áÇ       ‚ü® {!!} ‚ü©-‚â°
                                     Œ±‚ÇÅ ‚áÉ[ Œπ‚ÇÄ ‚óÜ ‚¶ó œÉ‚ÇÅ‚ÇÑ , _ ‚¶ò ]‚áÇ   ‚ü® {!!} ‚ü©-‚â°
                                     Œ±‚ÇÅ ‚áÉ[ œÉ‚ÇÅ‚ÇÑ ]‚áÇ                ‚ü® {!!} ‚ü©-‚â°
                                     Œ±‚ÇÄ ‚áÉ[ œÉ‚ÇÄ‚ÇÅ ]‚áÇ ‚áÉ[ œÉ‚ÇÅ‚ÇÑ ]‚áÇ      ‚ü® {!!} ‚ü©-‚â°
                                     Œ±‚ÇÄ ‚áÉ[ œÉ‚ÇÄ‚ÇÅ ‚óÜ œÉ‚ÇÅ‚ÇÑ ]‚áÇ          ‚ü® {!!} ‚ü©-‚â°
                                     Œ±‚ÇÄ ‚áÉ[ œÉ‚ÇÄ‚ÇÑ ]‚áÇ                ‚ü® typProof Œ©R‚ÇÄ ‚ü©-‚â°
                                     Œæ‚ÇÑ ‚áí Œ∂‚ÇÑ                    ‚àé-‚â°

                            -- ... thus we can use the universal property
                            -- to get ŒΩs‚ÇÉ ‚ü∂ ŒΩs‚ÇÑ
                            œÉ‚ÇÉ‚ÇÑ : ŒΩs‚ÇÉ ‚ü∂ ŒΩs‚ÇÑ
                            œÉ‚ÇÉ‚ÇÑ = {!!}

                            -- and we know that
                            lem-20 : œÉ·µ§‚ÇÉ ‚óÜ œÉ‚ÇÉ‚ÇÑ ‚àº œÉ·µ§‚ÇÑ
                            lem-20 = {!!}

                        in record { tiSub = œÉ‚ÇÉ‚ÇÑ ; typProof = {!!} ; ctxProof = {!!} ; subProof = lem-20 }
                -}

{-
                      let Œ©R‚ÇÄ = Œ©‚ÇÄ (Œ∂s ‚ä© Œû , (Œæ‚ÇÄ ‚áí Œæ‚ÇÅ) , Œì?<Œû , Œû‚ä¢Œæ‚ÇÄ‚áíŒæ‚ÇÅ)

                          œÉ·µ§‚ÇÄ = tiSub Œ©R‚ÇÄ

                          Œì‚ÇÄ<Œû : Œì‚ÇÄ <Œì Œû
                          Œì‚ÇÄ<Œû = record { fst = œÉ·µ§‚ÇÄ ; snd = ctxProof Œ©R‚ÇÄ }

                          Œ©R‚ÇÅ = Œ©‚ÇÅ (Œ∂s ‚ä© Œû , Œæ‚ÇÄ , Œì‚ÇÄ<Œû , Œû‚ä¢Œæ‚ÇÄ)

                          œÉ‚ÇÄ‚ÇÅ = tiSub Œ©R‚ÇÅ

                          aa = œÑ‚ÇÄ'' ‚áÉ[ œÉ·µ§‚ÇÄ ]‚áÇ


                      in record { tiSub = {!!} ; typProof = {!!} ; ctxProof = {!!} }

                      })

-}
-- the case of a lambda
Œ≥ {Œºs} {k} {Q = Q} Œì (lam te) = resn
  where
    -- create a new metavariable
    Œºs‚ÇÄ = Œºs ‚äî st

    Œ±·µò : ‚ÑíHMType ‚ü® st ‚ü©
    Œ±·µò = var incl

    Œ±‚ÇÄ : ‚ÑíHMType ‚ü® Œºs‚ÇÄ ‚äî ‚ä• ‚ü©
    Œ±‚ÇÄ = Œ±·µò ‚áÉ[ Œπ‚ÇÅ ‚óÜ Œπ‚ÇÄ ]‚áÇ

    -- create the context which contains this new variable
    Œì‚ÇÄ : ‚ÑíHMCtxFor Q Œºs‚ÇÄ
    Œì‚ÇÄ = Œì ‚áÉ[ Œπ‚ÇÄ ]‚áÇ-CtxFor

    œÉ‚ÇÄ : Œºs ‚ü∂ Œºs ‚äî st
    œÉ‚ÇÄ = Œπ‚ÇÄ

    -- call typechecking recursively on `te`
    res = Œ≥ (Œ±‚ÇÄ ‚à∑ Œì‚ÇÄ) te

    -- computing the initial typing instance
    -- assuming we have one for te
    success : InitialCtxTypingInstance (Œ±‚ÇÄ ‚à∑ Œì‚ÇÄ) te -> InitialCtxTypingInstance Œì (lam te)
    success ((Œºs‚ÇÅ ‚ä© (Œ±‚ÇÅ ‚à∑ Œì‚ÇÅ) , Œ≤‚ÇÅ , Œ±‚ÇÄŒì‚ÇÄ<Œ±‚ÇÅŒì‚ÇÅ , hastype) , Œ©) = ùëá , isInitial:ùëá
      where
        œÉ‚ÇÄ‚ÇÅ : Œºs‚ÇÄ ‚ü∂ Œºs‚ÇÅ
        œÉ‚ÇÄ‚ÇÅ = Œ±‚ÇÄŒì‚ÇÄ<Œ±‚ÇÅŒì‚ÇÅ .fst

        œÉ·µ§‚ÇÅ : Œºs ‚ü∂ Œºs‚ÇÅ
        œÉ·µ§‚ÇÅ = œÉ‚ÇÄ ‚óÜ œÉ‚ÇÄ‚ÇÅ

        lem-1 : Œì ‚áÉ[ œÉ·µ§‚ÇÅ ]‚áÇ-CtxFor ‚â° Œì‚ÇÅ
        lem-1 = Œì ‚áÉ[ œÉ·µ§‚ÇÅ ]‚áÇ-CtxFor                  ‚ü® sym-Path (functoriality-‚óÜ-‚áÉ[]‚áÇ-CtxFor {Œì = Œì} {f = œÉ‚ÇÄ} {œÉ‚ÇÄ‚ÇÅ}) ‚ü©-‚â°
                Œì ‚áÉ[ œÉ‚ÇÄ ]‚áÇ-CtxFor ‚áÉ[ œÉ‚ÇÄ‚ÇÅ ]‚áÇ-CtxFor  ‚ü® (Œª i -> split-DDList (Œ±‚ÇÄŒì‚ÇÄ<Œ±‚ÇÅŒì‚ÇÅ .snd i) .snd ) ‚ü©-‚â°
                Œì‚ÇÅ                                  ‚àé-‚â°

        Œì<Œì‚ÇÅ : Œì <Œì Œì‚ÇÅ
        Œì<Œì‚ÇÅ = record { fst = œÉ·µ§‚ÇÅ ; snd = lem-1 }

        ùëá : CtxTypingInstance Œì (lam te)
        ùëá = (Œºs‚ÇÅ ‚ä© Œì‚ÇÅ , _ , Œì<Œì‚ÇÅ , lam hastype)

        isInitial:ùëá : (ùëÜ : CtxTypingInstance Œì (lam te)) -> ùëá <TI ùëÜ
        isInitial:ùëá (Œºs‚ÇÇ ‚ä© Œì‚ÇÇ , .(_ ‚áí _) , Œì<Œì‚ÇÇ , lam {Œ± = Œ±‚ÇÇ} {Œ≤ = Œ≤‚ÇÇ} Œì‚ÇÇŒ±‚ÇÇ‚ä¢Œ≤‚ÇÇ) =
          record { tiSub = œÉ‚ÇÅ‚ÇÇ ; typProof = lem-30 ; subProof = lem-40 }

          where
            œÉ·µ§‚ÇÇ : Œºs ‚ü∂ Œºs‚ÇÇ
            œÉ·µ§‚ÇÇ = Œì<Œì‚ÇÇ .fst

            œÉ‚Çú‚ÇÇ : st ‚ü∂ Œºs‚ÇÇ
            œÉ‚Çú‚ÇÇ = ‚ßúsubst (incl Œ±‚ÇÇ) ‚óÜ ‚¶ó id , elim-‚ä• ‚¶ò

            -- Œºs ‚äî st = Œºs‚ÇÄ
            œÉ‚ÇÄ‚ÇÇ : (Œºs ‚äî st) ‚ü∂ Œºs‚ÇÇ
            œÉ‚ÇÄ‚ÇÇ = ‚¶ó œÉ·µ§‚ÇÇ , œÉ‚Çú‚ÇÇ ‚¶ò

            lem-5 : Œì‚ÇÄ ‚áÉ[ œÉ‚ÇÄ‚ÇÇ ]‚áÇ-CtxFor ‚â° Œì‚ÇÇ
            lem-5 = Œì ‚áÉ[ Œπ‚ÇÄ ]‚áÇ-CtxFor ‚áÉ[ œÉ‚ÇÄ‚ÇÇ ]‚áÇ-CtxFor  ‚ü® ¬ß-HM-Proofs.prop-2 œÉ·µ§‚ÇÇ œÉ‚Çú‚ÇÇ Œì ‚ü©-‚â°
                    Œì ‚áÉ[ œÉ·µ§‚ÇÇ ]‚áÇ-CtxFor                  ‚ü® Œì<Œì‚ÇÇ .snd ‚ü©-‚â°
                    Œì‚ÇÇ                                  ‚àé-‚â°

            lem-10 : (Œ±‚ÇÄ ‚à∑ Œì‚ÇÄ) ‚áÉ[ œÉ‚ÇÄ‚ÇÇ ]‚áÇ-CtxFor ‚â° (Œ±‚ÇÇ ‚à∑ Œì‚ÇÇ)
            lem-10 = Œª i ‚Üí ¬ß-HM-Proofs.prop-1 Œ±‚ÇÇ œÉ‚ÇÄ‚ÇÇ i ‚à∑ lem-5 i

            Œ±‚ÇÄŒì‚ÇÄ<Œ±‚ÇÇŒì‚ÇÇ : (Œ±‚ÇÄ ‚à∑ Œì‚ÇÄ) <Œì (Œ±‚ÇÇ ‚à∑ Œì‚ÇÇ)
            Œ±‚ÇÄŒì‚ÇÄ<Œ±‚ÇÇŒì‚ÇÇ = record { fst = œÉ‚ÇÄ‚ÇÇ ; snd = lem-10 }

            Œ©R = Œ© (Œºs‚ÇÇ ‚ä© (Œ±‚ÇÇ ‚à∑ Œì‚ÇÇ) , Œ≤‚ÇÇ , Œ±‚ÇÄŒì‚ÇÄ<Œ±‚ÇÇŒì‚ÇÇ , Œì‚ÇÇŒ±‚ÇÇ‚ä¢Œ≤‚ÇÇ)

            œÉ‚ÇÅ‚ÇÇ : Œºs‚ÇÅ ‚ü∂ Œºs‚ÇÇ
            œÉ‚ÇÅ‚ÇÇ = tiSub Œ©R

            lem-21 : (Œ±‚ÇÅ ‚à∑ Œì‚ÇÅ) ‚áÉ[ œÉ‚ÇÅ‚ÇÇ ]‚áÇ-CtxFor ‚â° Œ±‚ÇÇ ‚à∑ Œì‚ÇÇ
            lem-21 = ctxProofTI Œ©R

            lem-24 : Œ±‚ÇÅ ‚áÉ[ œÉ‚ÇÅ‚ÇÇ ‚áÉ‚äî‚áÇ id ]‚áÇ ‚â° Œ±‚ÇÇ
            lem-24 = Œª i ‚Üí split-DDList (lem-21 i) .fst

            lem-25 : Œ±‚ÇÅ ‚áÉ[ œÉ‚ÇÅ‚ÇÇ ‚áÉ‚äî‚áÇ id ]‚áÇ ‚áÉ[ ‚¶ó id , elim-‚ä• ‚¶ò ]‚áÇ ‚â° Œ±‚ÇÇ ‚áÉ[ ‚¶ó id , elim-‚ä• ‚¶ò ]‚áÇ
            lem-25 = cong _‚áÉ[ ‚¶ó id , elim-‚ä• ‚¶ò ]‚áÇ lem-24

            lem-26 : Œ±‚ÇÅ ‚áÉ[ ‚¶ó id , elim-‚ä• ‚¶ò ]‚áÇ ‚áÉ[ œÉ‚ÇÅ‚ÇÇ ]‚áÇ ‚â° Œ±‚ÇÇ ‚áÉ[ ‚¶ó id , elim-‚ä• ‚¶ò ]‚áÇ
            lem-26 = Œ±‚ÇÅ ‚áÉ[ ‚¶ó id , elim-‚ä• ‚¶ò ]‚áÇ ‚áÉ[ œÉ‚ÇÅ‚ÇÇ ]‚áÇ          ‚ü® functoriality-‚óÜ-‚áÉ[]‚áÇ {œÑ = Œ±‚ÇÅ} {f = ‚¶ó id , elim-‚ä• ‚¶ò} {g = œÉ‚ÇÅ‚ÇÇ} ‚ü©-‚â°
                    Œ±‚ÇÅ ‚áÉ[ ‚¶ó id , elim-‚ä• ‚¶ò ‚óÜ œÉ‚ÇÅ‚ÇÇ ]‚áÇ              ‚ü® Œ±‚ÇÅ ‚áÉ[‚âÄ ¬ß-HM-Helpers.prop-1 {f = œÉ‚ÇÅ‚ÇÇ} ‚âÄ]‚áÇ ‚ü©-‚â°
                    Œ±‚ÇÅ ‚áÉ[ (œÉ‚ÇÅ‚ÇÇ ‚áÉ‚äî‚áÇ id) ‚óÜ ‚¶ó id , elim-‚ä• ‚¶ò ]‚áÇ     ‚ü® sym-Path (functoriality-‚óÜ-‚áÉ[]‚áÇ {œÑ = Œ±‚ÇÅ} {f = œÉ‚ÇÅ‚ÇÇ ‚áÉ‚äî‚áÇ id} {g = ‚¶ó id , elim-‚ä• ‚¶ò}) ‚ü©-‚â°
                    Œ±‚ÇÅ ‚áÉ[ (œÉ‚ÇÅ‚ÇÇ ‚áÉ‚äî‚áÇ id) ]‚áÇ ‚áÉ[ ‚¶ó id , elim-‚ä• ‚¶ò ]‚áÇ ‚ü® lem-25 ‚ü©-‚â°
                    Œ±‚ÇÇ ‚áÉ[ ‚¶ó id , elim-‚ä• ‚¶ò ]‚áÇ                 ‚àé-‚â°

            lem-29 : Œ≤‚ÇÅ ‚áÉ[ œÉ‚ÇÅ‚ÇÇ ]‚áÇ ‚â° Œ≤‚ÇÇ
            lem-29 = typProof Œ©R

            lem-30 : (Œ±‚ÇÅ ‚áÉ[ ‚¶ó id , elim-‚ä• ‚¶ò ]‚áÇ ‚áí Œ≤‚ÇÅ) ‚áÉ[ œÉ‚ÇÅ‚ÇÇ ]‚áÇ ‚â° (Œ±‚ÇÇ ‚áÉ[ ‚¶ó id , elim-‚ä• ‚¶ò ]‚áÇ ‚áí Œ≤‚ÇÇ)
            lem-30 = Œª i ‚Üí lem-26 i ‚áí lem-29 i

            lem-40 : œÉ·µ§‚ÇÅ ‚óÜ œÉ‚ÇÅ‚ÇÇ ‚àº œÉ·µ§‚ÇÇ
            lem-40 = (œÉ‚ÇÄ ‚óÜ œÉ‚ÇÄ‚ÇÅ) ‚óÜ œÉ‚ÇÅ‚ÇÇ   ‚ü® assoc-l-‚óÜ {f = œÉ‚ÇÄ} {œÉ‚ÇÄ‚ÇÅ} {œÉ‚ÇÅ‚ÇÇ} ‚ü©-‚àº
                     œÉ‚ÇÄ ‚óÜ (œÉ‚ÇÄ‚ÇÅ ‚óÜ œÉ‚ÇÅ‚ÇÇ)   ‚ü® refl {x = œÉ‚ÇÄ} ‚óà subProof Œ©R ‚ü©-‚àº
                     œÉ‚ÇÄ ‚óÜ œÉ‚ÇÄ‚ÇÇ           ‚ü® reduce-Œπ‚ÇÄ {g = œÉ‚Çú‚ÇÇ} ‚ü©-‚àº
                     œÉ·µ§‚ÇÇ                ‚àé


    -------------------------------------------------
    -- putting it together

    -- distinguish between failure and not
    resn = case res of
      -- if there was a failure,
      -- we also have to fail
      (Œª ¬¨typing ‚Üí left
         -- assume we have a typing for lambda
         -- this means that we also have a typing for te
         -- which we know is impossible
         Œª {(ŒΩs ‚ä© Œî , œÑ , Œì‚ÇÄ<Œî , hastyp)
                ‚Üí let ŒΩs' , Œî' , œÑ' , hastyp' = ¬ß-isTyped‚ÑíHM.prop-1 te hastyp
                  in {!!} -- ¬¨typing (ŒΩs' ‚ä© Œî' , œÑ' , {!!} , hastyp')
                  })
      (right ‚àò success)



{-
      -- if there was no failure, we can use this result
      Œª {
        -- we know that `Œ±` has no quantification
          ((Œºs‚ÇÅ ‚ä© (Œ±‚ÇÅ ‚à∑ Œì‚ÇÅ) , Œ≤‚ÇÅ , Œ±‚ÇÄŒì‚ÇÄ<Œ±‚ÇÅŒì‚ÇÅ , hastype) , Œ©) ‚Üí
          let œÉ‚ÇÄ‚ÇÅ : Œºs‚ÇÄ ‚ü∂ Œºs‚ÇÅ
              œÉ‚ÇÄ‚ÇÅ = Œ±‚ÇÄŒì‚ÇÄ<Œ±‚ÇÅŒì‚ÇÅ .fst

              œÉ·µ§‚ÇÅ : Œºs ‚ü∂ Œºs‚ÇÅ
              œÉ·µ§‚ÇÅ = œÉ‚ÇÄ ‚óÜ œÉ‚ÇÄ‚ÇÅ

              lem-1 : Œì ‚áÉ[ œÉ·µ§‚ÇÅ ]‚áÇ-CtxFor ‚â° Œì‚ÇÅ
              lem-1 = Œì ‚áÉ[ œÉ·µ§‚ÇÅ ]‚áÇ-CtxFor                  ‚ü® sym-Path (functoriality-‚óÜ-‚áÉ[]‚áÇ-CtxFor {Œì = Œì} {f = œÉ‚ÇÄ} {œÉ‚ÇÄ‚ÇÅ}) ‚ü©-‚â°
                      Œì ‚áÉ[ œÉ‚ÇÄ ]‚áÇ-CtxFor ‚áÉ[ œÉ‚ÇÄ‚ÇÅ ]‚áÇ-CtxFor  ‚ü® (Œª i -> split-DDList (Œ±‚ÇÄŒì‚ÇÄ<Œ±‚ÇÅŒì‚ÇÅ .snd i) .snd ) ‚ü©-‚â°
                      Œì‚ÇÅ                                  ‚àé-‚â°

              Œì<Œì‚ÇÅ : Œì <Œì Œì‚ÇÅ
              Œì<Œì‚ÇÅ = record { fst = œÉ·µ§‚ÇÅ ; snd = lem-1 }

          in right ((Œºs‚ÇÅ ‚ä© Œì‚ÇÅ , _ , Œì<Œì‚ÇÅ , lam hastype),

                -- here we have to show that we are the best typing instance
                Œª {(Œºs‚ÇÇ ‚ä© Œì‚ÇÇ , .(_ ‚áí _) , Œì<Œì‚ÇÇ , lam {Œ± = Œ±‚ÇÇ} {Œ≤ = Œ≤‚ÇÇ} Œì‚ÇÇŒ±‚ÇÇ‚ä¢Œ≤‚ÇÇ) ‚Üí
                  let œÉ·µ§‚ÇÇ : Œºs ‚ü∂ Œºs‚ÇÇ
                      œÉ·µ§‚ÇÇ = Œì<Œì‚ÇÇ .fst

                      -- Œºs ‚äî st = Œºs‚ÇÄ
                      œÉ‚ÇÄ‚ÇÇ : (Œºs ‚äî st) ‚ü∂ Œºs‚ÇÇ
                      œÉ‚ÇÄ‚ÇÇ = ‚¶ó œÉ·µ§‚ÇÇ , ‚ßúsubst (incl Œ±‚ÇÇ) ‚óÜ ‚¶ó id , elim-‚ä• ‚¶ò ‚¶ò

                      lem-5 : Œì‚ÇÄ ‚áÉ[ œÉ‚ÇÄ‚ÇÇ ]‚áÇ-CtxFor ‚â° Œì‚ÇÇ
                      lem-5 = Œì ‚áÉ[ Œπ‚ÇÄ ]‚áÇ-CtxFor ‚áÉ[ œÉ‚ÇÄ‚ÇÇ ]‚áÇ-CtxFor  ‚ü® ¬ß-HM-Proofs.prop-2 œÉ·µ§‚ÇÇ (‚ßúsubst (incl Œ±‚ÇÇ) ‚óÜ ‚¶ó id , elim-‚ä• ‚¶ò) Œì ‚ü©-‚â°
                              Œì ‚áÉ[ œÉ·µ§‚ÇÇ ]‚áÇ-CtxFor                  ‚ü® Œì<Œì‚ÇÇ .snd ‚ü©-‚â°
                              Œì‚ÇÇ                                  ‚àé-‚â°

                      lem-10 : (Œ±‚ÇÄ ‚à∑ Œì‚ÇÄ) ‚áÉ[ œÉ‚ÇÄ‚ÇÇ ]‚áÇ-CtxFor ‚â° (Œ±‚ÇÇ ‚à∑ Œì‚ÇÇ)
                      lem-10 = Œª i ‚Üí ¬ß-HM-Proofs.prop-1 Œ±‚ÇÇ œÉ‚ÇÄ‚ÇÇ i ‚à∑ lem-5 i

                      Œ±‚ÇÄŒì‚ÇÄ<Œ±‚ÇÇŒì‚ÇÇ : (Œ±‚ÇÄ ‚à∑ Œì‚ÇÄ) <Œì (Œ±‚ÇÇ ‚à∑ Œì‚ÇÇ)
                      Œ±‚ÇÄŒì‚ÇÄ<Œ±‚ÇÇŒì‚ÇÇ = record { fst = œÉ‚ÇÄ‚ÇÇ ; snd = lem-10 }

                      Œ©R = Œ© (Œºs‚ÇÇ ‚ä© (Œ±‚ÇÇ ‚à∑ Œì‚ÇÇ) , Œ≤‚ÇÇ , Œ±‚ÇÄŒì‚ÇÄ<Œ±‚ÇÇŒì‚ÇÇ , Œì‚ÇÇŒ±‚ÇÇ‚ä¢Œ≤‚ÇÇ)

                  -- let Œ©R = Œ© (Œºs‚ÇÇ ‚ä© (Œ±‚ÇÇ ‚à∑ Œì‚ÇÇ) , Œ≤‚ÇÇ , {!!} , Œì‚ÇÇŒ±‚ÇÇ‚ä¢Œ≤‚ÇÇ)

                      œÉ‚ÇÅ‚ÇÇ : Œºs‚ÇÅ ‚ü∂ Œºs‚ÇÇ
                      œÉ‚ÇÅ‚ÇÇ = tiSub Œ©R

                      lem-21 : (Œ±‚ÇÅ ‚à∑ Œì‚ÇÅ) ‚áÉ[ œÉ‚ÇÅ‚ÇÇ ]‚áÇ-CtxFor ‚â° Œ±‚ÇÇ ‚à∑ Œì‚ÇÇ
                      lem-21 = ctxProofTI Œ©R

                      lem-24 : Œ±‚ÇÅ ‚áÉ[ œÉ‚ÇÅ‚ÇÇ ‚áÉ‚äî‚áÇ id ]‚áÇ ‚â° Œ±‚ÇÇ
                      lem-24 = Œª i ‚Üí split-DDList (lem-21 i) .fst

                      lem-25 : Œ±‚ÇÅ ‚áÉ[ œÉ‚ÇÅ‚ÇÇ ‚áÉ‚äî‚áÇ id ]‚áÇ ‚áÉ[ ‚¶ó id , elim-‚ä• ‚¶ò ]‚áÇ ‚â° Œ±‚ÇÇ ‚áÉ[ ‚¶ó id , elim-‚ä• ‚¶ò ]‚áÇ
                      lem-25 = cong _‚áÉ[ ‚¶ó id , elim-‚ä• ‚¶ò ]‚áÇ lem-24

                      lem-26 : Œ±‚ÇÅ ‚áÉ[ ‚¶ó id , elim-‚ä• ‚¶ò ]‚áÇ ‚áÉ[ œÉ‚ÇÅ‚ÇÇ ]‚áÇ ‚â° Œ±‚ÇÇ ‚áÉ[ ‚¶ó id , elim-‚ä• ‚¶ò ]‚áÇ
                      lem-26 = Œ±‚ÇÅ ‚áÉ[ ‚¶ó id , elim-‚ä• ‚¶ò ]‚áÇ ‚áÉ[ œÉ‚ÇÅ‚ÇÇ ]‚áÇ          ‚ü® functoriality-‚óÜ-‚áÉ[]‚áÇ {œÑ = Œ±‚ÇÅ} {f = ‚¶ó id , elim-‚ä• ‚¶ò} {g = œÉ‚ÇÅ‚ÇÇ} ‚ü©-‚â°
                              Œ±‚ÇÅ ‚áÉ[ ‚¶ó id , elim-‚ä• ‚¶ò ‚óÜ œÉ‚ÇÅ‚ÇÇ ]‚áÇ              ‚ü® Œ±‚ÇÅ ‚áÉ[‚âÄ ¬ß-HM-Helpers.prop-1 {f = œÉ‚ÇÅ‚ÇÇ} ‚âÄ]‚áÇ ‚ü©-‚â°
                              Œ±‚ÇÅ ‚áÉ[ (œÉ‚ÇÅ‚ÇÇ ‚áÉ‚äî‚áÇ id) ‚óÜ ‚¶ó id , elim-‚ä• ‚¶ò ]‚áÇ     ‚ü® sym-Path (functoriality-‚óÜ-‚áÉ[]‚áÇ {œÑ = Œ±‚ÇÅ} {f = œÉ‚ÇÅ‚ÇÇ ‚áÉ‚äî‚áÇ id} {g = ‚¶ó id , elim-‚ä• ‚¶ò}) ‚ü©-‚â°
                              Œ±‚ÇÅ ‚áÉ[ (œÉ‚ÇÅ‚ÇÇ ‚áÉ‚äî‚áÇ id) ]‚áÇ ‚áÉ[ ‚¶ó id , elim-‚ä• ‚¶ò ]‚áÇ ‚ü® lem-25 ‚ü©-‚â°
                              Œ±‚ÇÇ ‚áÉ[ ‚¶ó id , elim-‚ä• ‚¶ò ]‚áÇ                 ‚àé-‚â°

                      lem-29 : Œ≤‚ÇÅ ‚áÉ[ œÉ‚ÇÅ‚ÇÇ ]‚áÇ ‚â° Œ≤‚ÇÇ
                      lem-29 = typProof Œ©R

                      lem-30 : (Œ±‚ÇÅ ‚áÉ[ ‚¶ó id , elim-‚ä• ‚¶ò ]‚áÇ ‚áí Œ≤‚ÇÅ) ‚áÉ[ œÉ‚ÇÅ‚ÇÇ ]‚áÇ ‚â° (Œ±‚ÇÇ ‚áÉ[ ‚¶ó id , elim-‚ä• ‚¶ò ]‚áÇ ‚áí Œ≤‚ÇÇ)
                      lem-30 = Œª i ‚Üí lem-26 i ‚áí lem-29 i

                      lem-40 : œÉ·µ§‚ÇÅ ‚óÜ œÉ‚ÇÅ‚ÇÇ ‚àº œÉ·µ§‚ÇÇ
                      lem-40 = ?

                  in record { tiSub = œÉ‚ÇÅ‚ÇÇ ; typProof = lem-30 ; subProof = lem-40 }

                  })

        }
-}





